{"remainingRequest":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/babel-loader/lib/index.js!/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/eslint-loader/index.js??ref--13-0!/Users/weizhang/JAVASHOP/vue-admin-template-master/src/statics/viewer/pdf/web/pdf_presentation_mode.js","dependencies":[{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/src/statics/viewer/pdf/web/pdf_presentation_mode.js","mtime":1577806166000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\n\nvar _interopRequireDefault = require(\"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFPresentationMode = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _ui_utils = require(\"./ui_utils\");\n\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS = 1500; // in ms\n\nvar DELAY_BEFORE_HIDING_CONTROLS = 3000; // in ms\n\nvar ACTIVE_SELECTOR = 'pdfPresentationMode';\nvar CONTROLS_SELECTOR = 'pdfPresentationModeControls';\nvar MOUSE_SCROLL_COOLDOWN_TIME = 50; // in ms\n\nvar PAGE_SWITCH_THRESHOLD = 0.1; // Number of CSS pixels for a movement to count as a swipe.\n\nvar SWIPE_MIN_DISTANCE_THRESHOLD = 50; // Swipe angle deviation from the x or y axis before it is not\n// considered a swipe in that direction any more.\n\nvar SWIPE_ANGLE_THRESHOLD = Math.PI / 6;\n/**\n * @typedef {Object} PDFPresentationModeOptions\n * @property {HTMLDivElement} container - The container for the viewer element.\n * @property {HTMLDivElement} [viewer] - The viewer element.\n * @property {PDFViewer} pdfViewer - The document viewer.\n * @property {EventBus} eventBus - The application event bus.\n * @property {Array} [contextMenuItems] - The menu items that are added to the\n *   context menu in Presentation Mode.\n */\n\nvar PDFPresentationMode =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {PDFPresentationModeOptions} options\n   */\n  function PDFPresentationMode(_ref) {\n    var _this = this;\n\n    var container = _ref.container,\n        _ref$viewer = _ref.viewer,\n        viewer = _ref$viewer === void 0 ? null : _ref$viewer,\n        pdfViewer = _ref.pdfViewer,\n        eventBus = _ref.eventBus,\n        _ref$contextMenuItems = _ref.contextMenuItems,\n        contextMenuItems = _ref$contextMenuItems === void 0 ? null : _ref$contextMenuItems;\n    (0, _classCallCheck2.default)(this, PDFPresentationMode);\n    this.container = container;\n    this.viewer = viewer || container.firstElementChild;\n    this.pdfViewer = pdfViewer;\n    this.eventBus = eventBus;\n    this.active = false;\n    this.args = null;\n    this.contextMenuOpen = false;\n    this.mouseScrollTimeStamp = 0;\n    this.mouseScrollDelta = 0;\n    this.touchSwipeState = null;\n\n    if (contextMenuItems) {\n      contextMenuItems.contextFirstPage.addEventListener('click', function () {\n        _this.contextMenuOpen = false;\n\n        _this.eventBus.dispatch('firstpage', {\n          source: _this\n        });\n      });\n      contextMenuItems.contextLastPage.addEventListener('click', function () {\n        _this.contextMenuOpen = false;\n\n        _this.eventBus.dispatch('lastpage', {\n          source: _this\n        });\n      });\n      contextMenuItems.contextPageRotateCw.addEventListener('click', function () {\n        _this.contextMenuOpen = false;\n\n        _this.eventBus.dispatch('rotatecw', {\n          source: _this\n        });\n      });\n      contextMenuItems.contextPageRotateCcw.addEventListener('click', function () {\n        _this.contextMenuOpen = false;\n\n        _this.eventBus.dispatch('rotateccw', {\n          source: _this\n        });\n      });\n    }\n  }\n  /**\n   * Request the browser to enter fullscreen mode.\n   * @returns {boolean} Indicating if the request was successful.\n   */\n\n\n  (0, _createClass2.default)(PDFPresentationMode, [{\n    key: \"request\",\n    value: function request() {\n      if (this.switchInProgress || this.active || !this.viewer.hasChildNodes()) {\n        return false;\n      }\n\n      this._addFullscreenChangeListeners();\n\n      this._setSwitchInProgress();\n\n      this._notifyStateChange();\n\n      if (this.container.requestFullscreen) {\n        this.container.requestFullscreen();\n      } else if (this.container.mozRequestFullScreen) {\n        this.container.mozRequestFullScreen();\n      } else if (this.container.webkitRequestFullscreen) {\n        this.container.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n      } else if (this.container.msRequestFullscreen) {\n        this.container.msRequestFullscreen();\n      } else {\n        return false;\n      }\n\n      this.args = {\n        page: this.pdfViewer.currentPageNumber,\n        previousScale: this.pdfViewer.currentScaleValue\n      };\n      return true;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_mouseWheel\",\n    value: function _mouseWheel(evt) {\n      if (!this.active) {\n        return;\n      }\n\n      evt.preventDefault();\n      var delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);\n      var currentTime = new Date().getTime();\n      var storedTime = this.mouseScrollTimeStamp; // If we've already switched page, avoid accidentally switching again.\n\n      if (currentTime > storedTime && currentTime - storedTime < MOUSE_SCROLL_COOLDOWN_TIME) {\n        return;\n      } // If the scroll direction changed, reset the accumulated scroll delta.\n\n\n      if (this.mouseScrollDelta > 0 && delta < 0 || this.mouseScrollDelta < 0 && delta > 0) {\n        this._resetMouseScrollState();\n      }\n\n      this.mouseScrollDelta += delta;\n\n      if (Math.abs(this.mouseScrollDelta) >= PAGE_SWITCH_THRESHOLD) {\n        var totalDelta = this.mouseScrollDelta;\n\n        this._resetMouseScrollState();\n\n        var success = totalDelta > 0 ? this._goToPreviousPage() : this._goToNextPage();\n\n        if (success) {\n          this.mouseScrollTimeStamp = currentTime;\n        }\n      }\n    }\n  }, {\n    key: \"_goToPreviousPage\",\n\n    /**\n     * @private\n     */\n    value: function _goToPreviousPage() {\n      var page = this.pdfViewer.currentPageNumber; // If we're at the first page, we don't need to do anything.\n\n      if (page <= 1) {\n        return false;\n      }\n\n      this.pdfViewer.currentPageNumber = page - 1;\n      return true;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_goToNextPage\",\n    value: function _goToNextPage() {\n      var page = this.pdfViewer.currentPageNumber; // If we're at the last page, we don't need to do anything.\n\n      if (page >= this.pdfViewer.pagesCount) {\n        return false;\n      }\n\n      this.pdfViewer.currentPageNumber = page + 1;\n      return true;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_notifyStateChange\",\n    value: function _notifyStateChange() {\n      this.eventBus.dispatch('presentationmodechanged', {\n        source: this,\n        active: this.active,\n        switchInProgress: !!this.switchInProgress\n      });\n    }\n    /**\n     * Used to initialize a timeout when requesting Presentation Mode,\n     * i.e. when the browser is requested to enter fullscreen mode.\n     * This timeout is used to prevent the current page from being scrolled\n     * partially, or completely, out of view when entering Presentation Mode.\n     * NOTE: This issue seems limited to certain zoom levels (e.g. page-width).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setSwitchInProgress\",\n    value: function _setSwitchInProgress() {\n      var _this2 = this;\n\n      if (this.switchInProgress) {\n        clearTimeout(this.switchInProgress);\n      }\n\n      this.switchInProgress = setTimeout(function () {\n        _this2._removeFullscreenChangeListeners();\n\n        delete _this2.switchInProgress;\n\n        _this2._notifyStateChange();\n      }, DELAY_BEFORE_RESETTING_SWITCH_IN_PROGRESS);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_resetSwitchInProgress\",\n    value: function _resetSwitchInProgress() {\n      if (this.switchInProgress) {\n        clearTimeout(this.switchInProgress);\n        delete this.switchInProgress;\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_enter\",\n    value: function _enter() {\n      var _this3 = this;\n\n      this.active = true;\n\n      this._resetSwitchInProgress();\n\n      this._notifyStateChange();\n\n      this.container.classList.add(ACTIVE_SELECTOR); // Ensure that the correct page is scrolled into view when entering\n      // Presentation Mode, by waiting until fullscreen mode in enabled.\n\n      setTimeout(function () {\n        _this3.pdfViewer.currentPageNumber = _this3.args.page;\n        _this3.pdfViewer.currentScaleValue = 'page-fit';\n      }, 0);\n\n      this._addWindowListeners();\n\n      this._showControls();\n\n      this.contextMenuOpen = false;\n      this.container.setAttribute('contextmenu', 'viewerContextMenu'); // Text selection is disabled in Presentation Mode, thus it's not possible\n      // for the user to deselect text that is selected (e.g. with \"Select all\")\n      // when entering Presentation Mode, hence we remove any active selection.\n\n      window.getSelection().removeAllRanges();\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_exit\",\n    value: function _exit() {\n      var _this4 = this;\n\n      var page = this.pdfViewer.currentPageNumber;\n      this.container.classList.remove(ACTIVE_SELECTOR); // Ensure that the correct page is scrolled into view when exiting\n      // Presentation Mode, by waiting until fullscreen mode is disabled.\n\n      setTimeout(function () {\n        _this4.active = false;\n\n        _this4._removeFullscreenChangeListeners();\n\n        _this4._notifyStateChange();\n\n        _this4.pdfViewer.currentScaleValue = _this4.args.previousScale;\n        _this4.pdfViewer.currentPageNumber = page;\n        _this4.args = null;\n      }, 0);\n\n      this._removeWindowListeners();\n\n      this._hideControls();\n\n      this._resetMouseScrollState();\n\n      this.container.removeAttribute('contextmenu');\n      this.contextMenuOpen = false;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_mouseDown\",\n    value: function _mouseDown(evt) {\n      if (this.contextMenuOpen) {\n        this.contextMenuOpen = false;\n        evt.preventDefault();\n        return;\n      }\n\n      if (evt.button === 0) {\n        // Enable clicking of links in presentation mode. Note: only links\n        // pointing to destinations in the current PDF document work.\n        var isInternalLink = evt.target.href && evt.target.classList.contains('internalLink');\n\n        if (!isInternalLink) {\n          // Unless an internal link was clicked, advance one page.\n          evt.preventDefault();\n\n          if (evt.shiftKey) {\n            this._goToPreviousPage();\n          } else {\n            this._goToNextPage();\n          }\n        }\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_contextMenu\",\n    value: function _contextMenu() {\n      this.contextMenuOpen = true;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_showControls\",\n    value: function _showControls() {\n      var _this5 = this;\n\n      if (this.controlsTimeout) {\n        clearTimeout(this.controlsTimeout);\n      } else {\n        this.container.classList.add(CONTROLS_SELECTOR);\n      }\n\n      this.controlsTimeout = setTimeout(function () {\n        _this5.container.classList.remove(CONTROLS_SELECTOR);\n\n        delete _this5.controlsTimeout;\n      }, DELAY_BEFORE_HIDING_CONTROLS);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_hideControls\",\n    value: function _hideControls() {\n      if (!this.controlsTimeout) {\n        return;\n      }\n\n      clearTimeout(this.controlsTimeout);\n      this.container.classList.remove(CONTROLS_SELECTOR);\n      delete this.controlsTimeout;\n    }\n    /**\n     * Resets the properties used for tracking mouse scrolling events.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_resetMouseScrollState\",\n    value: function _resetMouseScrollState() {\n      this.mouseScrollTimeStamp = 0;\n      this.mouseScrollDelta = 0;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_touchSwipe\",\n    value: function _touchSwipe(evt) {\n      if (!this.active) {\n        return;\n      }\n\n      if (evt.touches.length > 1) {\n        // Multiple touch points detected; cancel the swipe.\n        this.touchSwipeState = null;\n        return;\n      }\n\n      switch (evt.type) {\n        case 'touchstart':\n          this.touchSwipeState = {\n            startX: evt.touches[0].pageX,\n            startY: evt.touches[0].pageY,\n            endX: evt.touches[0].pageX,\n            endY: evt.touches[0].pageY\n          };\n          break;\n\n        case 'touchmove':\n          if (this.touchSwipeState === null) {\n            return;\n          }\n\n          this.touchSwipeState.endX = evt.touches[0].pageX;\n          this.touchSwipeState.endY = evt.touches[0].pageY; // Avoid the swipe from triggering browser gestures (Chrome in\n          // particular has some sort of swipe gesture in fullscreen mode).\n\n          evt.preventDefault();\n          break;\n\n        case 'touchend':\n          if (this.touchSwipeState === null) {\n            return;\n          }\n\n          var delta = 0;\n          var dx = this.touchSwipeState.endX - this.touchSwipeState.startX;\n          var dy = this.touchSwipeState.endY - this.touchSwipeState.startY;\n          var absAngle = Math.abs(Math.atan2(dy, dx));\n\n          if (Math.abs(dx) > SWIPE_MIN_DISTANCE_THRESHOLD && (absAngle <= SWIPE_ANGLE_THRESHOLD || absAngle >= Math.PI - SWIPE_ANGLE_THRESHOLD)) {\n            // Horizontal swipe.\n            delta = dx;\n          } else if (Math.abs(dy) > SWIPE_MIN_DISTANCE_THRESHOLD && Math.abs(absAngle - Math.PI / 2) <= SWIPE_ANGLE_THRESHOLD) {\n            // Vertical swipe.\n            delta = dy;\n          }\n\n          if (delta > 0) {\n            this._goToPreviousPage();\n          } else if (delta < 0) {\n            this._goToNextPage();\n          }\n\n          break;\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_addWindowListeners\",\n    value: function _addWindowListeners() {\n      this.showControlsBind = this._showControls.bind(this);\n      this.mouseDownBind = this._mouseDown.bind(this);\n      this.mouseWheelBind = this._mouseWheel.bind(this);\n      this.resetMouseScrollStateBind = this._resetMouseScrollState.bind(this);\n      this.contextMenuBind = this._contextMenu.bind(this);\n      this.touchSwipeBind = this._touchSwipe.bind(this);\n      window.addEventListener('mousemove', this.showControlsBind);\n      window.addEventListener('mousedown', this.mouseDownBind);\n      window.addEventListener('wheel', this.mouseWheelBind);\n      window.addEventListener('keydown', this.resetMouseScrollStateBind);\n      window.addEventListener('contextmenu', this.contextMenuBind);\n      window.addEventListener('touchstart', this.touchSwipeBind);\n      window.addEventListener('touchmove', this.touchSwipeBind);\n      window.addEventListener('touchend', this.touchSwipeBind);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_removeWindowListeners\",\n    value: function _removeWindowListeners() {\n      window.removeEventListener('mousemove', this.showControlsBind);\n      window.removeEventListener('mousedown', this.mouseDownBind);\n      window.removeEventListener('wheel', this.mouseWheelBind);\n      window.removeEventListener('keydown', this.resetMouseScrollStateBind);\n      window.removeEventListener('contextmenu', this.contextMenuBind);\n      window.removeEventListener('touchstart', this.touchSwipeBind);\n      window.removeEventListener('touchmove', this.touchSwipeBind);\n      window.removeEventListener('touchend', this.touchSwipeBind);\n      delete this.showControlsBind;\n      delete this.mouseDownBind;\n      delete this.mouseWheelBind;\n      delete this.resetMouseScrollStateBind;\n      delete this.contextMenuBind;\n      delete this.touchSwipeBind;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_fullscreenChange\",\n    value: function _fullscreenChange() {\n      if (this.isFullscreen) {\n        this._enter();\n      } else {\n        this._exit();\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_addFullscreenChangeListeners\",\n    value: function _addFullscreenChangeListeners() {\n      this.fullscreenChangeBind = this._fullscreenChange.bind(this);\n      window.addEventListener('fullscreenchange', this.fullscreenChangeBind);\n      window.addEventListener('mozfullscreenchange', this.fullscreenChangeBind);\n\n      if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n        window.addEventListener('webkitfullscreenchange', this.fullscreenChangeBind);\n        window.addEventListener('MSFullscreenChange', this.fullscreenChangeBind);\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_removeFullscreenChangeListeners\",\n    value: function _removeFullscreenChangeListeners() {\n      window.removeEventListener('fullscreenchange', this.fullscreenChangeBind);\n      window.removeEventListener('mozfullscreenchange', this.fullscreenChangeBind);\n\n      if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n        window.removeEventListener('webkitfullscreenchange', this.fullscreenChangeBind);\n        window.removeEventListener('MSFullscreenChange', this.fullscreenChangeBind);\n      }\n\n      delete this.fullscreenChangeBind;\n    }\n  }, {\n    key: \"isFullscreen\",\n    get: function get() {\n      return !!(document.fullscreenElement || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement);\n    }\n  }]);\n  return PDFPresentationMode;\n}();\n\nexports.PDFPresentationMode = PDFPresentationMode;",null]}