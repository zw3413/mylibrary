{"remainingRequest":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/babel-loader/lib/index.js!/Users/weizhang/JAVASHOP/mylibrary-ui/src/statics/viewer/pdf/web/app.js","dependencies":[{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/src/statics/viewer/pdf/web/app.js","mtime":1577893570000},{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFPrintServiceFactory = exports.DefaultExternalServices = exports.PDFViewerApplication = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/@babel/runtime/regenerator\"));\n\nvar _ui_utils = require(\"./ui_utils\");\n\nvar _app_options = require(\"./app_options\");\n\nvar _pdfjsDist = require(\"pdfjs-dist\");\n\nvar _pdf_cursor_tools = require(\"./pdf_cursor_tools\");\n\nvar _pdf_rendering_queue = require(\"./pdf_rendering_queue\");\n\nvar _pdf_sidebar = require(\"./pdf_sidebar\");\n\nvar _overlay_manager = require(\"./overlay_manager\");\n\nvar _password_prompt = require(\"./password_prompt\");\n\nvar _pdf_attachment_viewer = require(\"./pdf_attachment_viewer\");\n\nvar _pdf_document_properties = require(\"./pdf_document_properties\");\n\nvar _pdf_find_bar = require(\"./pdf_find_bar\");\n\nvar _pdf_find_controller = require(\"./pdf_find_controller\");\n\nvar _pdf_history = require(\"./pdf_history\");\n\nvar _pdf_link_service = require(\"./pdf_link_service\");\n\nvar _pdf_outline_viewer = require(\"./pdf_outline_viewer\");\n\nvar _pdf_presentation_mode = require(\"./pdf_presentation_mode\");\n\nvar _pdf_sidebar_resizer = require(\"./pdf_sidebar_resizer\");\n\nvar _pdf_thumbnail_viewer = require(\"./pdf_thumbnail_viewer\");\n\nvar _pdf_viewer = require(\"./pdf_viewer\");\n\nvar _secondary_toolbar = require(\"./secondary_toolbar\");\n\nvar _toolbar = require(\"./toolbar\");\n\nvar _view_history = require(\"./view_history\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar DEFAULT_SCALE_DELTA = 1.1;\nvar DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000; // ms\n\nvar FORCE_PAGES_LOADED_TIMEOUT = 10000; // ms\n\nvar WHEEL_ZOOM_DISABLED_TIMEOUT = 1000; // ms\n\nvar ViewOnLoad = {\n  UNKNOWN: -1,\n  PREVIOUS: 0,\n  // Default value.\n  INITIAL: 1\n};\nvar DefaultExternalServices = {\n  updateFindControlState: function updateFindControlState(data) {},\n  updateFindMatchesCount: function updateFindMatchesCount(data) {},\n  initPassiveLoading: function initPassiveLoading(callbacks) {},\n  fallback: function fallback(data, callback) {},\n  reportTelemetry: function reportTelemetry(data) {},\n  createDownloadManager: function createDownloadManager(options) {\n    throw new Error('Not implemented: createDownloadManager');\n  },\n  createPreferences: function createPreferences() {\n    throw new Error('Not implemented: createPreferences');\n  },\n  createL10n: function createL10n(options) {\n    throw new Error('Not implemented: createL10n');\n  },\n  supportsIntegratedFind: false,\n  supportsDocumentFonts: true,\n  supportsDocumentColors: true,\n  supportedMouseWheelZoomModifierKeys: {\n    ctrlKey: true,\n    metaKey: true\n  }\n};\nexports.DefaultExternalServices = DefaultExternalServices;\nvar PDFViewerApplication = {\n  initialBookmark: document.location.hash.substring(1),\n  initialized: false,\n  fellback: false,\n  appConfig: null,\n  pdfDocument: null,\n  pdfLoadingTask: null,\n  printService: null,\n\n  /** @type {PDFViewer} */\n  pdfViewer: null,\n\n  /** @type {PDFThumbnailViewer} */\n  pdfThumbnailViewer: null,\n\n  /** @type {PDFRenderingQueue} */\n  pdfRenderingQueue: null,\n\n  /** @type {PDFPresentationMode} */\n  pdfPresentationMode: null,\n\n  /** @type {PDFDocumentProperties} */\n  pdfDocumentProperties: null,\n\n  /** @type {PDFLinkService} */\n  pdfLinkService: null,\n\n  /** @type {PDFHistory} */\n  pdfHistory: null,\n\n  /** @type {PDFSidebar} */\n  pdfSidebar: null,\n\n  /** @type {PDFSidebarResizer} */\n  pdfSidebarResizer: null,\n\n  /** @type {PDFOutlineViewer} */\n  pdfOutlineViewer: null,\n\n  /** @type {PDFAttachmentViewer} */\n  pdfAttachmentViewer: null,\n\n  /** @type {PDFCursorTools} */\n  pdfCursorTools: null,\n\n  /** @type {ViewHistory} */\n  store: null,\n\n  /** @type {DownloadManager} */\n  downloadManager: null,\n\n  /** @type {OverlayManager} */\n  overlayManager: null,\n\n  /** @type {Preferences} */\n  preferences: null,\n\n  /** @type {Toolbar} */\n  toolbar: null,\n\n  /** @type {SecondaryToolbar} */\n  secondaryToolbar: null,\n\n  /** @type {EventBus} */\n  eventBus: null,\n\n  /** @type {IL10n} */\n  l10n: null,\n  isInitialViewSet: false,\n  downloadComplete: false,\n  isViewerEmbedded: window.parent !== window,\n  url: '',\n  baseUrl: '',\n  externalServices: DefaultExternalServices,\n  _boundEvents: {},\n  contentDispositionFilename: null,\n  // Called once when the document is loaded.\n  initialize: function () {\n    var _initialize = _asyncToGenerator(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee(appConfig) {\n      var _this = this;\n\n      var appContainer;\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this.preferences = this.externalServices.createPreferences();\n              this.appConfig = appConfig;\n              _context.next = 4;\n              return this._readPreferences();\n\n            case 4:\n              _context.next = 6;\n              return this._parseHashParameters();\n\n            case 6:\n              _context.next = 8;\n              return this._initializeL10n();\n\n            case 8:\n              if (this.isViewerEmbedded && _app_options.AppOptions.get('externalLinkTarget') === _pdfjsDist.LinkTarget.NONE) {\n                // Prevent external links from \"replacing\" the viewer,\n                // when it's embedded in e.g. an <iframe> or an <object>.\n                _app_options.AppOptions.set('externalLinkTarget', _pdfjsDist.LinkTarget.TOP);\n              }\n\n              _context.next = 11;\n              return this._initializeViewerComponents();\n\n            case 11:\n              // Bind the various event handlers *after* the viewer has been\n              // initialized, to prevent errors if an event arrives too soon.\n              this.bindEvents();\n              this.bindWindowEvents(); // We can start UI localization now.\n\n              appContainer = appConfig.appContainer || document.documentElement;\n              this.l10n.translate(appContainer).then(function () {\n                // Dispatch the 'localized' event on the `eventBus` once the viewer\n                // has been fully initialized and translated.\n                _this.eventBus.dispatch('localized', {\n                  source: _this\n                });\n              });\n              this.initialized = true;\n              webViewerInitialized();\n\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function initialize(_x) {\n      return _initialize.apply(this, arguments);\n    }\n\n    return initialize;\n  }(),\n\n  /**\n   * @private\n   */\n  _readPreferences: function () {\n    var _readPreferences2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee2() {\n      var prefs, name;\n      return _regenerator.default.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(_app_options.AppOptions.get('disablePreferences') === true)) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              _context2.prev = 2;\n              _context2.next = 5;\n              return this.preferences.getAll();\n\n            case 5:\n              prefs = _context2.sent;\n\n              for (name in prefs) {\n                _app_options.AppOptions.set(name, prefs[name]);\n              }\n\n              _context2.next = 12;\n              break;\n\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](2);\n              console.error(\"_readPreferences: \\\"\".concat(_context2.t0.message, \"\\\".\"));\n\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this, [[2, 9]]);\n    }));\n\n    function _readPreferences() {\n      return _readPreferences2.apply(this, arguments);\n    }\n\n    return _readPreferences;\n  }(),\n\n  /**\n   * @private\n   */\n  _parseHashParameters: function () {\n    var _parseHashParameters2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee3() {\n      var waitOn, hash, hashParams, viewer, enabled;\n      return _regenerator.default.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(typeof PDFJSDev !== 'undefined' && PDFJSDev.test('PRODUCTION') && !_app_options.AppOptions.get('pdfBugEnabled'))) {\n                _context3.next = 2;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", undefined);\n\n            case 2:\n              waitOn = []; // Special debugging flags in the hash section of the URL.\n\n              hash = document.location.hash.substring(1);\n              hashParams = (0, _ui_utils.parseQueryString)(hash);\n\n              if ('disableworker' in hashParams && hashParams['disableworker'] === 'true') {\n                waitOn.push(loadFakeWorker());\n              }\n\n              if ('disablerange' in hashParams) {\n                _app_options.AppOptions.set('disableRange', hashParams['disablerange'] === 'true');\n              }\n\n              if ('disablestream' in hashParams) {\n                _app_options.AppOptions.set('disableStream', hashParams['disablestream'] === 'true');\n              }\n\n              if ('disableautofetch' in hashParams) {\n                _app_options.AppOptions.set('disableAutoFetch', hashParams['disableautofetch'] === 'true');\n              }\n\n              if ('disablefontface' in hashParams) {\n                _app_options.AppOptions.set('disableFontFace', hashParams['disablefontface'] === 'true');\n              }\n\n              if ('disablehistory' in hashParams) {\n                _app_options.AppOptions.set('disableHistory', hashParams['disablehistory'] === 'true');\n              }\n\n              if ('webgl' in hashParams) {\n                _app_options.AppOptions.set('enableWebGL', hashParams['webgl'] === 'true');\n              }\n\n              if ('useonlycsszoom' in hashParams) {\n                _app_options.AppOptions.set('useOnlyCssZoom', hashParams['useonlycsszoom'] === 'true');\n              }\n\n              if ('verbosity' in hashParams) {\n                _app_options.AppOptions.set('verbosity', hashParams['verbosity'] | 0);\n              }\n\n              if (!('textlayer' in hashParams)) {\n                _context3.next = 23;\n                break;\n              }\n\n              _context3.t0 = hashParams['textlayer'];\n              _context3.next = _context3.t0 === 'off' ? 18 : _context3.t0 === 'visible' ? 20 : _context3.t0 === 'shadow' ? 20 : _context3.t0 === 'hover' ? 20 : 23;\n              break;\n\n            case 18:\n              _app_options.AppOptions.set('textLayerMode', _ui_utils.TextLayerMode.DISABLE);\n\n              return _context3.abrupt(\"break\", 23);\n\n            case 20:\n              viewer = this.appConfig.viewerContainer;\n              viewer.classList.add('textLayer-' + hashParams['textlayer']);\n              return _context3.abrupt(\"break\", 23);\n\n            case 23:\n              if ('pdfbug' in hashParams) {\n                _app_options.AppOptions.set('pdfBug', true);\n\n                enabled = hashParams['pdfbug'].split(',');\n                waitOn.push(loadAndEnablePDFBug(enabled));\n              } // It is not possible to change locale for the (various) extension builds.\n\n\n              if ((typeof PDFJSDev === 'undefined' || PDFJSDev.test('!PRODUCTION || GENERIC')) && 'locale' in hashParams) {\n                _app_options.AppOptions.set('locale', hashParams['locale']);\n              }\n\n              return _context3.abrupt(\"return\", Promise.all(waitOn).catch(function (reason) {\n                console.error(\"_parseHashParameters: \\\"\".concat(reason.message, \"\\\".\"));\n              }));\n\n            case 26:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    function _parseHashParameters() {\n      return _parseHashParameters2.apply(this, arguments);\n    }\n\n    return _parseHashParameters;\n  }(),\n\n  /**\n   * @private\n   */\n  _initializeL10n: function () {\n    var _initializeL10n2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee4() {\n      return _regenerator.default.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              this.l10n = this.externalServices.createL10n({\n                locale: _app_options.AppOptions.get('locale')\n              }); //const dir = await this.l10n.getDirection();\n              //document.getElementsByTagName('html')[0].dir = dir;\n\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n\n    function _initializeL10n() {\n      return _initializeL10n2.apply(this, arguments);\n    }\n\n    return _initializeL10n;\n  }(),\n\n  /**\n   * @private\n   */\n  _initializeViewerComponents: function () {\n    var _initializeViewerComponents2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee5() {\n      var appConfig, eventBus, pdfRenderingQueue, pdfLinkService, downloadManager, findController, container, viewer;\n      return _regenerator.default.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              appConfig = this.appConfig;\n              this.overlayManager = new _overlay_manager.OverlayManager();\n              eventBus = appConfig.eventBus || (0, _ui_utils.getGlobalEventBus)(_app_options.AppOptions.get('eventBusDispatchToDOM'));\n              this.eventBus = eventBus;\n              pdfRenderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();\n              pdfRenderingQueue.onIdle = this.cleanup.bind(this);\n              this.pdfRenderingQueue = pdfRenderingQueue;\n              pdfLinkService = new _pdf_link_service.PDFLinkService({\n                eventBus: eventBus,\n                externalLinkTarget: _app_options.AppOptions.get('externalLinkTarget'),\n                externalLinkRel: _app_options.AppOptions.get('externalLinkRel')\n              });\n              this.pdfLinkService = pdfLinkService;\n              downloadManager = this.externalServices.createDownloadManager({\n                disableCreateObjectURL: _app_options.AppOptions.get('disableCreateObjectURL')\n              });\n              this.downloadManager = downloadManager;\n              findController = new _pdf_find_controller.PDFFindController({\n                linkService: pdfLinkService,\n                eventBus: eventBus\n              });\n              this.findController = findController;\n              container = appConfig.mainContainer;\n              viewer = appConfig.viewerContainer;\n              this.pdfViewer = new _pdf_viewer.PDFViewer({\n                container: container,\n                viewer: viewer,\n                eventBus: eventBus,\n                renderingQueue: pdfRenderingQueue,\n                linkService: pdfLinkService,\n                downloadManager: downloadManager,\n                findController: findController,\n                renderer: _app_options.AppOptions.get('renderer'),\n                enableWebGL: _app_options.AppOptions.get('enableWebGL'),\n                l10n: this.l10n,\n                textLayerMode: _app_options.AppOptions.get('textLayerMode'),\n                imageResourcesPath: _app_options.AppOptions.get('imageResourcesPath'),\n                renderInteractiveForms: _app_options.AppOptions.get('renderInteractiveForms'),\n                enablePrintAutoRotate: _app_options.AppOptions.get('enablePrintAutoRotate'),\n                useOnlyCssZoom: _app_options.AppOptions.get('useOnlyCssZoom'),\n                maxCanvasPixels: _app_options.AppOptions.get('maxCanvasPixels')\n              });\n              pdfRenderingQueue.setViewer(this.pdfViewer);\n              pdfLinkService.setViewer(this.pdfViewer);\n              this.pdfThumbnailViewer = new _pdf_thumbnail_viewer.PDFThumbnailViewer({\n                container: appConfig.sidebar.thumbnailView,\n                renderingQueue: pdfRenderingQueue,\n                linkService: pdfLinkService,\n                l10n: this.l10n\n              });\n              pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer);\n              this.pdfHistory = new _pdf_history.PDFHistory({\n                linkService: pdfLinkService,\n                eventBus: eventBus\n              });\n              pdfLinkService.setHistory(this.pdfHistory);\n\n              if (!this.supportsIntegratedFind) {\n                this.findBar = new _pdf_find_bar.PDFFindBar(appConfig.findBar, eventBus, this.l10n);\n              }\n\n              this.pdfDocumentProperties = new _pdf_document_properties.PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n);\n              this.pdfCursorTools = new _pdf_cursor_tools.PDFCursorTools({\n                container: container,\n                eventBus: eventBus,\n                cursorToolOnLoad: _app_options.AppOptions.get('cursorToolOnLoad')\n              });\n              this.toolbar = new _toolbar.Toolbar(appConfig.toolbar, eventBus, this.l10n);\n              this.secondaryToolbar = new _secondary_toolbar.SecondaryToolbar(appConfig.secondaryToolbar, container, eventBus);\n\n              if (this.supportsFullscreen) {\n                this.pdfPresentationMode = new _pdf_presentation_mode.PDFPresentationMode({\n                  container: container,\n                  viewer: viewer,\n                  pdfViewer: this.pdfViewer,\n                  eventBus: eventBus,\n                  contextMenuItems: appConfig.fullscreen\n                });\n              }\n\n              this.passwordPrompt = new _password_prompt.PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n);\n              this.pdfOutlineViewer = new _pdf_outline_viewer.PDFOutlineViewer({\n                container: appConfig.sidebar.outlineView,\n                eventBus: eventBus,\n                linkService: pdfLinkService\n              });\n              this.pdfAttachmentViewer = new _pdf_attachment_viewer.PDFAttachmentViewer({\n                container: appConfig.sidebar.attachmentsView,\n                eventBus: eventBus,\n                downloadManager: downloadManager\n              });\n              this.pdfSidebar = new _pdf_sidebar.PDFSidebar({\n                elements: appConfig.sidebar,\n                pdfViewer: this.pdfViewer,\n                pdfThumbnailViewer: this.pdfThumbnailViewer,\n                eventBus: eventBus,\n                l10n: this.l10n\n              });\n              this.pdfSidebar.onToggled = this.forceRendering.bind(this);\n              this.pdfSidebarResizer = new _pdf_sidebar_resizer.PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n);\n\n            case 34:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this);\n    }));\n\n    function _initializeViewerComponents() {\n      return _initializeViewerComponents2.apply(this, arguments);\n    }\n\n    return _initializeViewerComponents;\n  }(),\n  run: function run(config) {\n    this.initialize(config).then(webViewerInitialized);\n  },\n  zoomIn: function zoomIn(ticks) {\n    if (this.pdfViewer.isInPresentationMode) {\n      return;\n    }\n\n    var newScale = this.pdfViewer.currentScale;\n\n    do {\n      newScale = (newScale * DEFAULT_SCALE_DELTA).toFixed(2);\n      newScale = Math.ceil(newScale * 10) / 10;\n      newScale = Math.min(_ui_utils.MAX_SCALE, newScale);\n    } while (--ticks > 0 && newScale < _ui_utils.MAX_SCALE);\n\n    this.pdfViewer.currentScaleValue = newScale;\n  },\n  zoomOut: function zoomOut(ticks) {\n    if (this.pdfViewer.isInPresentationMode) {\n      return;\n    }\n\n    var newScale = this.pdfViewer.currentScale;\n\n    do {\n      newScale = (newScale / DEFAULT_SCALE_DELTA).toFixed(2);\n      newScale = Math.floor(newScale * 10) / 10;\n      newScale = Math.max(_ui_utils.MIN_SCALE, newScale);\n    } while (--ticks > 0 && newScale > _ui_utils.MIN_SCALE);\n\n    this.pdfViewer.currentScaleValue = newScale;\n  },\n  zoomReset: function zoomReset() {\n    if (this.pdfViewer.isInPresentationMode) {\n      return;\n    }\n\n    this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;\n  },\n\n  get pagesCount() {\n    return this.pdfDocument ? this.pdfDocument.numPages : 0;\n  },\n\n  set page(val) {\n    this.pdfViewer.currentPageNumber = val;\n  },\n\n  get page() {\n    return this.pdfViewer.currentPageNumber;\n  },\n\n  get printing() {\n    return !!this.printService;\n  },\n\n  get supportsPrinting() {\n    return PDFPrintServiceFactory.instance.supportsPrinting;\n  },\n\n  get supportsFullscreen() {\n    var support;\n\n    if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('MOZCENTRAL')) {\n      support = document.fullscreenEnabled === true || document.mozFullScreenEnabled === true;\n    } else {\n      var doc = document.documentElement;\n      support = !!(doc.requestFullscreen || doc.mozRequestFullScreen || doc.webkitRequestFullScreen || doc.msRequestFullscreen);\n\n      if (document.fullscreenEnabled === false || document.mozFullScreenEnabled === false || document.webkitFullscreenEnabled === false || document.msFullscreenEnabled === false) {\n        support = false;\n      }\n    }\n\n    return (0, _pdfjsDist.shadow)(this, 'supportsFullscreen', support);\n  },\n\n  get supportsIntegratedFind() {\n    return this.externalServices.supportsIntegratedFind;\n  },\n\n  get supportsDocumentFonts() {\n    return this.externalServices.supportsDocumentFonts;\n  },\n\n  get supportsDocumentColors() {\n    return this.externalServices.supportsDocumentColors;\n  },\n\n  get loadingBar() {\n    var bar = new _ui_utils.ProgressBar('#loadingBar');\n    return (0, _pdfjsDist.shadow)(this, 'loadingBar', bar);\n  },\n\n  get supportedMouseWheelZoomModifierKeys() {\n    return this.externalServices.supportedMouseWheelZoomModifierKeys;\n  },\n\n  initPassiveLoading: function initPassiveLoading() {\n    if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL || CHROME')) {\n      throw new Error('Not implemented: initPassiveLoading');\n    }\n\n    this.externalServices.initPassiveLoading({\n      onOpenWithTransport: function onOpenWithTransport(url, length, transport) {\n        PDFViewerApplication.open(url, {\n          length: length,\n          range: transport\n        });\n      },\n      onOpenWithData: function onOpenWithData(data) {\n        PDFViewerApplication.open(data);\n      },\n      onOpenWithURL: function onOpenWithURL(url, length, originalUrl) {\n        var file = url,\n            args = null;\n\n        if (length !== undefined) {\n          args = {\n            length: length\n          };\n        }\n\n        if (originalUrl !== undefined) {\n          file = {\n            url: url,\n            originalUrl: originalUrl\n          };\n        }\n\n        PDFViewerApplication.open(file, args);\n      },\n      onError: function onError(err) {\n        PDFViewerApplication.l10n.get('loading_error', null, 'An error occurred while loading the PDF.').then(function (msg) {\n          PDFViewerApplication.error(msg, err);\n        });\n      },\n      onProgress: function onProgress(loaded, total) {\n        PDFViewerApplication.progress(loaded / total);\n      }\n    });\n  },\n  setTitleUsingUrl: function setTitleUsingUrl() {\n    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    this.url = url;\n    this.baseUrl = url.split('#')[0];\n    var title = (0, _ui_utils.getPDFFileNameFromURL)(url, '');\n\n    if (!title) {\n      try {\n        title = decodeURIComponent((0, _pdfjsDist.getFilenameFromUrl)(url)) || url;\n      } catch (ex) {\n        // decodeURIComponent may throw URIError,\n        // fall back to using the unprocessed url in that case\n        title = url;\n      }\n    }\n\n    this.setTitle(title);\n  },\n  setTitle: function setTitle(title) {\n    if (this.isViewerEmbedded) {\n      // Embedded PDF viewers should not be changing their parent page's title.\n      return;\n    }\n\n    document.title = title;\n  },\n\n  /**\n   * Closes opened PDF document.\n   * @returns {Promise} - Returns the promise, which is resolved when all\n   *                      destruction is completed.\n   */\n  close: function () {\n    var _close = _asyncToGenerator(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee6() {\n      var errorWrapper, promise;\n      return _regenerator.default.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              errorWrapper = this.appConfig.errorWrapper.container;\n              errorWrapper.setAttribute('hidden', 'true');\n\n              if (this.pdfLoadingTask) {\n                _context6.next = 4;\n                break;\n              }\n\n              return _context6.abrupt(\"return\", undefined);\n\n            case 4:\n              promise = this.pdfLoadingTask.destroy();\n              this.pdfLoadingTask = null;\n\n              if (this.pdfDocument) {\n                this.pdfDocument = null;\n                this.pdfThumbnailViewer.setDocument(null);\n                this.pdfViewer.setDocument(null);\n                this.pdfLinkService.setDocument(null);\n                this.pdfDocumentProperties.setDocument(null);\n              }\n\n              this.store = null;\n              this.isInitialViewSet = false;\n              this.downloadComplete = false;\n              this.url = '';\n              this.baseUrl = '';\n              this.contentDispositionFilename = null;\n              this.pdfSidebar.reset();\n              this.pdfOutlineViewer.reset();\n              this.pdfAttachmentViewer.reset();\n\n              if (this.findBar) {\n                this.findBar.reset();\n              }\n\n              this.toolbar.reset();\n              this.secondaryToolbar.reset();\n\n              if (typeof PDFBug !== 'undefined') {\n                PDFBug.cleanup();\n              }\n\n              return _context6.abrupt(\"return\", promise);\n\n            case 21:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6, this);\n    }));\n\n    function close() {\n      return _close.apply(this, arguments);\n    }\n\n    return close;\n  }(),\n\n  /**\n   * Opens PDF document specified by URL or array with additional arguments.\n   * @param {string|TypedArray|ArrayBuffer} file - PDF location or binary data.\n   * @param {Object} [args] - Additional arguments for the getDocument call,\n   *                          e.g. HTTP headers ('httpHeaders') or alternative\n   *                          data transport ('range').\n   * @returns {Promise} - Returns the promise, which is resolved when document\n   *                      is opened.\n   */\n  open: function () {\n    var _open = _asyncToGenerator(\n    /*#__PURE__*/\n    _regenerator.default.mark(function _callee7(file, args) {\n      var _this2 = this;\n\n      var workerParameters, key, parameters, apiParameters, _key, value, _key2, _value, loadingTask;\n\n      return _regenerator.default.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!this.pdfLoadingTask) {\n                _context7.next = 3;\n                break;\n              }\n\n              _context7.next = 3;\n              return this.close();\n\n            case 3:\n              // Set the necessary global worker parameters, using the available options.\n              workerParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.WORKER);\n\n              for (key in workerParameters) {\n                _pdfjsDist.GlobalWorkerOptions[key] = workerParameters[key];\n              }\n\n              parameters = Object.create(null);\n\n              if (typeof file === 'string') {\n                // URL\n                this.setTitleUsingUrl(file);\n                parameters.url = file;\n              } else if (file && 'byteLength' in file) {\n                // ArrayBuffer\n                parameters.data = file;\n              } else if (file.url && file.originalUrl) {\n                this.setTitleUsingUrl(file.originalUrl);\n                parameters.url = file.url;\n              } // Set the necessary API parameters, using the available options.\n\n\n              apiParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.API);\n\n              for (_key in apiParameters) {\n                value = apiParameters[_key];\n\n                if (_key === 'docBaseUrl' && !value) {\n                  if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION')) {\n                    value = document.URL.split('#')[0];\n                  } else if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('FIREFOX || MOZCENTRAL || CHROME')) {\n                    value = this.baseUrl;\n                  }\n                }\n\n                parameters[_key] = value;\n              }\n\n              if (args) {\n                for (_key2 in args) {\n                  _value = args[_key2];\n\n                  if (_key2 === 'length') {\n                    this.pdfDocumentProperties.setFileSize(_value);\n                  }\n\n                  parameters[_key2] = _value;\n                }\n              }\n\n              loadingTask = (0, _pdfjsDist.getDocument)(parameters);\n              this.pdfLoadingTask = loadingTask;\n\n              loadingTask.onPassword = function (updateCallback, reason) {\n                _this2.pdfLinkService.externalLinkEnabled = false;\n\n                _this2.passwordPrompt.setUpdateCallback(updateCallback, reason);\n\n                _this2.passwordPrompt.open();\n              };\n\n              loadingTask.onProgress = function (_ref) {\n                var loaded = _ref.loaded,\n                    total = _ref.total;\n\n                _this2.progress(loaded / total);\n              }; // Listen for unsupported features to trigger the fallback UI.\n\n\n              loadingTask.onUnsupportedFeature = this.fallback.bind(this);\n              return _context7.abrupt(\"return\", loadingTask.promise.then(function (pdfDocument) {\n                _this2.load(pdfDocument);\n              }, function (exception) {\n                if (loadingTask !== _this2.pdfLoadingTask) {\n                  return undefined; // Ignore errors for previously opened PDF files.\n                }\n\n                var message = exception && exception.message;\n                var loadingErrorMessage;\n\n                if (exception instanceof _pdfjsDist.InvalidPDFException) {\n                  // change error message also for other builds\n                  loadingErrorMessage = _this2.l10n.get('invalid_file_error', null, 'Invalid or corrupted PDF file.');\n                } else if (exception instanceof _pdfjsDist.MissingPDFException) {\n                  // special message for missing PDF's\n                  loadingErrorMessage = _this2.l10n.get('missing_file_error', null, 'Missing PDF file.');\n                } else if (exception instanceof _pdfjsDist.UnexpectedResponseException) {\n                  loadingErrorMessage = _this2.l10n.get('unexpected_response_error', null, 'Unexpected server response.');\n                } else {\n                  loadingErrorMessage = _this2.l10n.get('loading_error', null, 'An error occurred while loading the PDF.');\n                }\n\n                return loadingErrorMessage.then(function (msg) {\n                  _this2.error(msg, {\n                    message: message\n                  });\n\n                  throw new Error(msg);\n                });\n              }));\n\n            case 16:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, this);\n    }));\n\n    function open(_x2, _x3) {\n      return _open.apply(this, arguments);\n    }\n\n    return open;\n  }(),\n  download: function download() {\n    var _this3 = this;\n\n    function downloadByUrl() {\n      downloadManager.downloadUrl(url, filename);\n    }\n\n    var url = this.baseUrl; // Use this.url instead of this.baseUrl to perform filename detection based\n    // on the reference fragment as ultimate fallback if needed.\n\n    var filename = this.contentDispositionFilename || (0, _ui_utils.getPDFFileNameFromURL)(this.url);\n    var downloadManager = this.downloadManager;\n\n    downloadManager.onerror = function (err) {\n      // This error won't really be helpful because it's likely the\n      // fallback won't work either (or is already open).\n      _this3.error(\"PDF failed to download: \".concat(err));\n    }; // When the PDF document isn't ready, or the PDF file is still downloading,\n    // simply download using the URL.\n\n\n    if (!this.pdfDocument || !this.downloadComplete) {\n      downloadByUrl();\n      return;\n    }\n\n    this.pdfDocument.getData().then(function (data) {\n      var blob = new Blob([data], {\n        type: 'application/pdf'\n      });\n      downloadManager.download(blob, url, filename);\n    }).catch(downloadByUrl); // Error occurred, try downloading with the URL.\n  },\n  fallback: function fallback(featureId) {\n    if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n      // Only trigger the fallback once so we don't spam the user with messages\n      // for one PDF.\n      if (this.fellback) {\n        return;\n      }\n\n      this.fellback = true;\n      this.externalServices.fallback({\n        featureId: featureId,\n        url: this.baseUrl\n      }, function response(download) {\n        if (!download) {\n          return;\n        }\n\n        PDFViewerApplication.download();\n      });\n    }\n  },\n\n  /**\n   * Show the error box.\n   * @param {string} message - A message that is human readable.\n   * @param {Object} [moreInfo] - Further information about the error that is\n   *                              more technical.  Should have a 'message' and\n   *                              optionally a 'stack' property.\n   */\n  error: function error(message, moreInfo) {\n    var moreInfoText = [this.l10n.get('error_version_info', {\n      version: _pdfjsDist.version || '?',\n      build: _pdfjsDist.build || '?'\n    }, 'PDF.js v{{version}} (build: {{build}})')];\n\n    if (moreInfo) {\n      moreInfoText.push(this.l10n.get('error_message', {\n        message: moreInfo.message\n      }, 'Message: {{message}}'));\n\n      if (moreInfo.stack) {\n        moreInfoText.push(this.l10n.get('error_stack', {\n          stack: moreInfo.stack\n        }, 'Stack: {{stack}}'));\n      } else {\n        if (moreInfo.filename) {\n          moreInfoText.push(this.l10n.get('error_file', {\n            file: moreInfo.filename\n          }, 'File: {{file}}'));\n        }\n\n        if (moreInfo.lineNumber) {\n          moreInfoText.push(this.l10n.get('error_line', {\n            line: moreInfo.lineNumber\n          }, 'Line: {{line}}'));\n        }\n      }\n    }\n\n    if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n      var errorWrapperConfig = this.appConfig.errorWrapper;\n      var errorWrapper = errorWrapperConfig.container;\n      errorWrapper.removeAttribute('hidden');\n      var errorMessage = errorWrapperConfig.errorMessage;\n      errorMessage.textContent = message;\n      var closeButton = errorWrapperConfig.closeButton;\n\n      closeButton.onclick = function () {\n        errorWrapper.setAttribute('hidden', 'true');\n      };\n\n      var errorMoreInfo = errorWrapperConfig.errorMoreInfo;\n      var moreInfoButton = errorWrapperConfig.moreInfoButton;\n      var lessInfoButton = errorWrapperConfig.lessInfoButton;\n\n      moreInfoButton.onclick = function () {\n        errorMoreInfo.removeAttribute('hidden');\n        moreInfoButton.setAttribute('hidden', 'true');\n        lessInfoButton.removeAttribute('hidden');\n        errorMoreInfo.style.height = errorMoreInfo.scrollHeight + 'px';\n      };\n\n      lessInfoButton.onclick = function () {\n        errorMoreInfo.setAttribute('hidden', 'true');\n        moreInfoButton.removeAttribute('hidden');\n        lessInfoButton.setAttribute('hidden', 'true');\n      };\n\n      moreInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;\n      lessInfoButton.oncontextmenu = _ui_utils.noContextMenuHandler;\n      closeButton.oncontextmenu = _ui_utils.noContextMenuHandler;\n      moreInfoButton.removeAttribute('hidden');\n      lessInfoButton.setAttribute('hidden', 'true');\n      Promise.all(moreInfoText).then(function (parts) {\n        errorMoreInfo.value = parts.join('\\n');\n      });\n    } else {\n      Promise.all(moreInfoText).then(function (parts) {\n        console.error(message + '\\n' + parts.join('\\n'));\n      });\n      this.fallback();\n    }\n  },\n  progress: function progress(level) {\n    var _this4 = this;\n\n    if (this.downloadComplete) {\n      // Don't accidentally show the loading bar again when the entire file has\n      // already been fetched (only an issue when disableAutoFetch is enabled).\n      return;\n    }\n\n    var percent = Math.round(level * 100); // When we transition from full request to range requests, it's possible\n    // that we discard some of the loaded data. This can cause the loading\n    // bar to move backwards. So prevent this by only updating the bar if it\n    // increases.\n\n    if (percent > this.loadingBar.percent || isNaN(percent)) {\n      this.loadingBar.percent = percent; // When disableAutoFetch is enabled, it's not uncommon for the entire file\n      // to never be fetched (depends on e.g. the file structure). In this case\n      // the loading bar will not be completely filled, nor will it be hidden.\n      // To prevent displaying a partially filled loading bar permanently, we\n      // hide it when no data has been loaded during a certain amount of time.\n\n      var disableAutoFetch = this.pdfDocument ? this.pdfDocument.loadingParams['disableAutoFetch'] : _app_options.AppOptions.get('disableAutoFetch');\n\n      if (disableAutoFetch && percent) {\n        if (this.disableAutoFetchLoadingBarTimeout) {\n          clearTimeout(this.disableAutoFetchLoadingBarTimeout);\n          this.disableAutoFetchLoadingBarTimeout = null;\n        }\n\n        this.loadingBar.show();\n        this.disableAutoFetchLoadingBarTimeout = setTimeout(function () {\n          _this4.loadingBar.hide();\n\n          _this4.disableAutoFetchLoadingBarTimeout = null;\n        }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT);\n      }\n    }\n  },\n  load: function load(pdfDocument) {\n    var _this5 = this;\n\n    this.pdfDocument = pdfDocument;\n    pdfDocument.getDownloadInfo().then(function () {\n      _this5.downloadComplete = true;\n\n      _this5.loadingBar.hide();\n\n      firstPagePromise.then(function () {\n        _this5.eventBus.dispatch('documentloaded', {\n          source: _this5\n        });\n      });\n    }); // Since the `setInitialView` call below depends on this being resolved,\n    // fetch it early to avoid delaying initial rendering of the PDF document.\n\n    var pageLayoutPromise = pdfDocument.getPageLayout().catch(function () {\n      /* Avoid breaking initial rendering; ignoring errors. */\n    });\n    var pageModePromise = pdfDocument.getPageMode().catch(function () {\n      /* Avoid breaking initial rendering; ignoring errors. */\n    });\n    var openActionDestPromise = pdfDocument.getOpenActionDestination().catch(function () {\n      /* Avoid breaking initial rendering; ignoring errors. */\n    });\n    this.toolbar.setPagesCount(pdfDocument.numPages, false);\n    this.secondaryToolbar.setPagesCount(pdfDocument.numPages);\n    var store = this.store = new _view_history.ViewHistory(pdfDocument.fingerprint);\n    var baseDocumentUrl;\n\n    if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n      baseDocumentUrl = null;\n    } else if (PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n      baseDocumentUrl = this.baseUrl;\n    } else if (PDFJSDev.test('CHROME')) {\n      baseDocumentUrl = location.href.split('#')[0];\n    }\n\n    this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl);\n    this.pdfDocumentProperties.setDocument(pdfDocument, this.url);\n    var pdfViewer = this.pdfViewer;\n    pdfViewer.setDocument(pdfDocument);\n    var firstPagePromise = pdfViewer.firstPagePromise;\n    var pagesPromise = pdfViewer.pagesPromise;\n    var onePageRendered = pdfViewer.onePageRendered;\n    var pdfThumbnailViewer = this.pdfThumbnailViewer;\n    pdfThumbnailViewer.setDocument(pdfDocument);\n    firstPagePromise.then(function (pdfPage) {\n      _this5.loadingBar.setWidth(_this5.appConfig.viewerContainer);\n\n      var storePromise = store.getMultiple({\n        page: null,\n        zoom: _ui_utils.DEFAULT_SCALE_VALUE,\n        scrollLeft: '0',\n        scrollTop: '0',\n        rotation: null,\n        sidebarView: _pdf_sidebar.SidebarView.UNKNOWN,\n        scrollMode: _ui_utils.ScrollMode.UNKNOWN,\n        spreadMode: _ui_utils.SpreadMode.UNKNOWN\n      }).catch(function () {\n        /* Unable to read from storage; ignoring errors. */\n      });\n      Promise.all([_ui_utils.animationStarted, storePromise, pageLayoutPromise, pageModePromise, openActionDestPromise]).then(\n      /*#__PURE__*/\n      function () {\n        var _ref3 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regenerator.default.mark(function _callee8(_ref2) {\n          var _ref4, timeStamp, _ref4$, values, pageLayout, pageMode, openActionDest, viewOnLoad, initialBookmark, zoom, hash, rotation, sidebarView, scrollMode, spreadMode;\n\n          return _regenerator.default.wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  _ref4 = _slicedToArray(_ref2, 5), timeStamp = _ref4[0], _ref4$ = _ref4[1], values = _ref4$ === void 0 ? {} : _ref4$, pageLayout = _ref4[2], pageMode = _ref4[3], openActionDest = _ref4[4];\n                  viewOnLoad = _app_options.AppOptions.get('viewOnLoad');\n\n                  _this5._initializePdfHistory({\n                    fingerprint: pdfDocument.fingerprint,\n                    viewOnLoad: viewOnLoad,\n                    initialDest: openActionDest\n                  });\n\n                  initialBookmark = _this5.initialBookmark; // Initialize the default values, from user preferences.\n\n                  zoom = _app_options.AppOptions.get('defaultZoomValue');\n                  hash = zoom ? \"zoom=\".concat(zoom) : null;\n                  rotation = null;\n                  sidebarView = _app_options.AppOptions.get('sidebarViewOnLoad');\n                  scrollMode = _app_options.AppOptions.get('scrollModeOnLoad');\n                  spreadMode = _app_options.AppOptions.get('spreadModeOnLoad');\n\n                  if (values.page && viewOnLoad !== ViewOnLoad.INITIAL) {\n                    hash = \"page=\".concat(values.page, \"&zoom=\").concat(zoom || values.zoom, \",\") + \"\".concat(values.scrollLeft, \",\").concat(values.scrollTop);\n                    rotation = parseInt(values.rotation, 10); // Always let user preferences take precedence over the view history.\n\n                    if (sidebarView === _pdf_sidebar.SidebarView.UNKNOWN) {\n                      sidebarView = values.sidebarView | 0;\n                    }\n\n                    if (scrollMode === _ui_utils.ScrollMode.UNKNOWN) {\n                      scrollMode = values.scrollMode | 0;\n                    }\n\n                    if (spreadMode === _ui_utils.SpreadMode.UNKNOWN) {\n                      spreadMode = values.spreadMode | 0;\n                    }\n                  } // Always let the user preference/view history take precedence.\n\n\n                  if (pageMode && sidebarView === _pdf_sidebar.SidebarView.UNKNOWN) {\n                    sidebarView = apiPageModeToSidebarView(pageMode);\n                  }\n\n                  if (pageLayout && spreadMode === _ui_utils.SpreadMode.UNKNOWN) {\n                    spreadMode = apiPageLayoutToSpreadMode(pageLayout);\n                  }\n\n                  _this5.setInitialView(hash, {\n                    rotation: rotation,\n                    sidebarView: sidebarView,\n                    scrollMode: scrollMode,\n                    spreadMode: spreadMode\n                  });\n\n                  _this5.eventBus.dispatch('documentinit', {\n                    source: _this5\n                  }); // Make all navigation keys work on document load,\n                  // unless the viewer is embedded in a web page.\n\n\n                  if (!_this5.isViewerEmbedded) {\n                    pdfViewer.focus();\n                  } // For documents with different page sizes, once all pages are resolved,\n                  // ensure that the correct location becomes visible on load.\n                  // (To reduce the risk, in very large and/or slow loading documents,\n                  //  that the location changes *after* the user has started interacting\n                  //  with the viewer, wait for either `pagesPromise` or a timeout.)\n\n\n                  _context8.next = 18;\n                  return Promise.race([pagesPromise, new Promise(function (resolve) {\n                    setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT);\n                  })]);\n\n                case 18:\n                  if (!(!initialBookmark && !hash)) {\n                    _context8.next = 20;\n                    break;\n                  }\n\n                  return _context8.abrupt(\"return\");\n\n                case 20:\n                  if (!pdfViewer.hasEqualPageSizes) {\n                    _context8.next = 22;\n                    break;\n                  }\n\n                  return _context8.abrupt(\"return\");\n\n                case 22:\n                  _this5.initialBookmark = initialBookmark; // eslint-disable-next-line no-self-assign\n\n                  pdfViewer.currentScaleValue = pdfViewer.currentScaleValue; // Re-apply the initial document location.\n\n                  _this5.setInitialView(hash);\n\n                case 25:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8);\n        }));\n\n        return function (_x4) {\n          return _ref3.apply(this, arguments);\n        };\n      }()).catch(function () {\n        // Ensure that the document is always completely initialized,\n        // even if there are any errors thrown above.\n        _this5.setInitialView();\n      }).then(function () {\n        // At this point, rendering of the initial page(s) should always have\n        // started (and may even have completed).\n        // To prevent any future issues, e.g. the document being completely\n        // blank on load, always trigger rendering here.\n        pdfViewer.update();\n      });\n    });\n    pdfDocument.getPageLabels().then(function (labels) {\n      if (!labels || _app_options.AppOptions.get('disablePageLabels')) {\n        return;\n      }\n\n      var i = 0,\n          numLabels = labels.length;\n\n      if (numLabels !== _this5.pagesCount) {\n        console.error('The number of Page Labels does not match ' + 'the number of pages in the document.');\n        return;\n      } // Ignore page labels that correspond to standard page numbering.\n\n\n      while (i < numLabels && labels[i] === (i + 1).toString()) {\n        i++;\n      }\n\n      if (i === numLabels) {\n        return;\n      }\n\n      pdfViewer.setPageLabels(labels);\n      pdfThumbnailViewer.setPageLabels(labels); // Changing toolbar page display to use labels and we need to set\n      // the label of the current page.\n\n      _this5.toolbar.setPagesCount(pdfDocument.numPages, true);\n\n      _this5.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);\n    });\n    pagesPromise.then(function () {\n      if (!_this5.supportsPrinting) {\n        return;\n      }\n\n      pdfDocument.getJavaScript().then(function (javaScript) {\n        if (!javaScript) {\n          return;\n        }\n\n        javaScript.some(function (js) {\n          if (!js) {\n            // Don't warn/fallback for empty JavaScript actions.\n            return false;\n          }\n\n          console.warn('Warning: JavaScript is not supported');\n\n          _this5.fallback(_pdfjsDist.UNSUPPORTED_FEATURES.javaScript);\n\n          return true;\n        }); // Hack to support auto printing.\n\n        var regex = /\\bprint\\s*\\(/;\n\n        for (var i = 0, ii = javaScript.length; i < ii; i++) {\n          var js = javaScript[i];\n\n          if (js && regex.test(js)) {\n            setTimeout(function () {\n              window.print();\n            });\n            return;\n          }\n        }\n      });\n    });\n    onePageRendered.then(function () {\n      pdfDocument.getOutline().then(function (outline) {\n        _this5.pdfOutlineViewer.render({\n          outline: outline\n        });\n      });\n      pdfDocument.getAttachments().then(function (attachments) {\n        _this5.pdfAttachmentViewer.render({\n          attachments: attachments\n        });\n      });\n    });\n    pdfDocument.getMetadata().then(function (_ref5) {\n      var info = _ref5.info,\n          metadata = _ref5.metadata,\n          contentDispositionFilename = _ref5.contentDispositionFilename;\n      _this5.documentInfo = info;\n      _this5.metadata = metadata;\n      _this5.contentDispositionFilename = contentDispositionFilename; // Provides some basic debug information\n\n      console.log('PDF ' + pdfDocument.fingerprint + ' [' + info.PDFFormatVersion + ' ' + (info.Producer || '-').trim() + ' / ' + (info.Creator || '-').trim() + ']' + ' (PDF.js: ' + (_pdfjsDist.version || '-') + (_app_options.AppOptions.get('enableWebGL') ? ' [WebGL]' : '') + ')');\n      var pdfTitle;\n\n      if (metadata && metadata.has('dc:title')) {\n        var title = metadata.get('dc:title'); // Ghostscript sometimes return 'Untitled', sets the title to 'Untitled'\n\n        if (title !== 'Untitled') {\n          pdfTitle = title;\n        }\n      }\n\n      if (!pdfTitle && info && info['Title']) {\n        pdfTitle = info['Title'];\n      }\n\n      if (pdfTitle) {\n        _this5.setTitle(\"\".concat(pdfTitle, \" - \").concat(contentDispositionFilename || document.title));\n      } else if (contentDispositionFilename) {\n        _this5.setTitle(contentDispositionFilename);\n      }\n\n      if (info.IsAcroFormPresent) {\n        console.warn('Warning: AcroForm/XFA is not supported');\n\n        _this5.fallback(_pdfjsDist.UNSUPPORTED_FEATURES.forms);\n      }\n\n      if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n        // Telemetry labels must be C++ variable friendly.\n        var versionId = \"v\".concat(info.PDFFormatVersion.replace('.', '_'));\n        var generatorId = 'other'; // Keep these in sync with mozilla central's Histograms.json.\n\n        var KNOWN_GENERATORS = ['acrobat distiller', 'acrobat pdfwriter', 'adobe livecycle', 'adobe pdf library', 'adobe photoshop', 'ghostscript', 'tcpdf', 'cairo', 'dvipdfm', 'dvips', 'pdftex', 'pdfkit', 'itext', 'prince', 'quarkxpress', 'mac os x', 'microsoft', 'openoffice', 'oracle', 'luradocument', 'pdf-xchange', 'antenna house', 'aspose.cells', 'fpdf'];\n\n        if (info.Producer) {\n          KNOWN_GENERATORS.some(function (generator, s, i) {\n            if (!generator.includes(s)) {\n              return false;\n            }\n\n            generatorId = s.replace(/[ .\\-]/g, '_');\n            return true;\n          }.bind(null, info.Producer.toLowerCase()));\n        }\n\n        var formType = !info.IsAcroFormPresent ? null : info.IsXFAPresent ? 'xfa' : 'acroform';\n\n        _this5.externalServices.reportTelemetry({\n          type: 'documentInfo',\n          version: versionId,\n          generator: generatorId,\n          formType: formType\n        });\n      }\n    });\n  },\n\n  /**\n   * @private\n   */\n  _initializePdfHistory: function _initializePdfHistory(_ref6) {\n    var fingerprint = _ref6.fingerprint,\n        viewOnLoad = _ref6.viewOnLoad,\n        _ref6$initialDest = _ref6.initialDest,\n        initialDest = _ref6$initialDest === void 0 ? null : _ref6$initialDest;\n\n    if (_app_options.AppOptions.get('disableHistory') || this.isViewerEmbedded) {\n      // The browsing history is only enabled when the viewer is standalone,\n      // i.e. not when it is embedded in a web page.\n      return;\n    }\n\n    this.pdfHistory.initialize({\n      fingerprint: fingerprint,\n      resetHistory: viewOnLoad === ViewOnLoad.INITIAL,\n      updateUrl: _app_options.AppOptions.get('historyUpdateUrl')\n    });\n\n    if (this.pdfHistory.initialBookmark) {\n      this.initialBookmark = this.pdfHistory.initialBookmark;\n      this.initialRotation = this.pdfHistory.initialRotation;\n    } // Always let the browser history/document hash take precedence.\n\n\n    if (initialDest && !this.initialBookmark && viewOnLoad === ViewOnLoad.UNKNOWN) {\n      this.initialBookmark = JSON.stringify(initialDest); // TODO: Re-factor the `PDFHistory` initialization to remove this hack\n      // that's currently necessary to prevent weird initial history state.\n\n      this.pdfHistory.push({\n        explicitDest: initialDest,\n        pageNumber: null\n      });\n    }\n  },\n  setInitialView: function setInitialView(storedHash) {\n    var _this6 = this;\n\n    var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        rotation = _ref7.rotation,\n        sidebarView = _ref7.sidebarView,\n        scrollMode = _ref7.scrollMode,\n        spreadMode = _ref7.spreadMode;\n\n    var setRotation = function setRotation(angle) {\n      if ((0, _ui_utils.isValidRotation)(angle)) {\n        _this6.pdfViewer.pagesRotation = angle;\n      }\n    };\n\n    var setViewerModes = function setViewerModes(scroll, spread) {\n      if ((0, _ui_utils.isValidScrollMode)(scroll)) {\n        _this6.pdfViewer.scrollMode = scroll;\n      }\n\n      if ((0, _ui_utils.isValidSpreadMode)(spread)) {\n        _this6.pdfViewer.spreadMode = spread;\n      }\n    };\n\n    this.isInitialViewSet = true;\n    this.pdfSidebar.setInitialView(sidebarView);\n    setViewerModes(scrollMode, spreadMode);\n\n    if (this.initialBookmark) {\n      setRotation(this.initialRotation);\n      delete this.initialRotation;\n      this.pdfLinkService.setHash(this.initialBookmark);\n      this.initialBookmark = null;\n    } else if (storedHash) {\n      setRotation(rotation);\n      this.pdfLinkService.setHash(storedHash);\n    } // Ensure that the correct page number is displayed in the UI,\n    // even if the active page didn't change during document load.\n\n\n    this.toolbar.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel);\n    this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber);\n\n    if (!this.pdfViewer.currentScaleValue) {\n      // Scale was not initialized: invalid bookmark or scale was not specified.\n      // Setting the default one.\n      this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;\n    }\n  },\n  cleanup: function cleanup() {\n    if (!this.pdfDocument) {\n      return; // run cleanup when document is loaded\n    }\n\n    this.pdfViewer.cleanup();\n    this.pdfThumbnailViewer.cleanup(); // We don't want to remove fonts used by active page SVGs.\n\n    if (this.pdfViewer.renderer !== _ui_utils.RendererType.SVG) {\n      this.pdfDocument.cleanup();\n    }\n  },\n  forceRendering: function forceRendering() {\n    this.pdfRenderingQueue.printing = this.printing;\n    this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar.isThumbnailViewVisible;\n    this.pdfRenderingQueue.renderHighestPriority();\n  },\n  beforePrint: function beforePrint() {\n    var _this7 = this;\n\n    if (this.printService) {\n      // There is no way to suppress beforePrint/afterPrint events,\n      // but PDFPrintService may generate double events -- this will ignore\n      // the second event that will be coming from native window.print().\n      return;\n    }\n\n    if (!this.supportsPrinting) {\n      this.l10n.get('printing_not_supported', null, 'Warning: Printing is not fully supported by ' + 'this browser.').then(function (printMessage) {\n        _this7.error(printMessage);\n      });\n      return;\n    } // The beforePrint is a sync method and we need to know layout before\n    // returning from this method. Ensure that we can get sizes of the pages.\n\n\n    if (!this.pdfViewer.pageViewsReady) {\n      this.l10n.get('printing_not_ready', null, 'Warning: The PDF is not fully loaded for printing.').then(function (notReadyMessage) {\n        window.alert(notReadyMessage);\n      });\n      return;\n    }\n\n    var pagesOverview = this.pdfViewer.getPagesOverview();\n    var printContainer = this.appConfig.printContainer;\n    var printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, this.l10n);\n    this.printService = printService;\n    this.forceRendering();\n    printService.layout();\n\n    if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n      this.externalServices.reportTelemetry({\n        type: 'print'\n      });\n    }\n  },\n  afterPrint: function afterPrint() {\n    if (this.printService) {\n      this.printService.destroy();\n      this.printService = null;\n    }\n\n    this.forceRendering();\n  },\n  rotatePages: function rotatePages(delta) {\n    if (!this.pdfDocument) {\n      return;\n    }\n\n    var newRotation = (this.pdfViewer.pagesRotation + 360 + delta) % 360;\n    this.pdfViewer.pagesRotation = newRotation; // Note that the thumbnail viewer is updated, and rendering is triggered,\n    // in the 'rotationchanging' event handler.\n  },\n  requestPresentationMode: function requestPresentationMode() {\n    if (!this.pdfPresentationMode) {\n      return;\n    }\n\n    this.pdfPresentationMode.request();\n  },\n  bindEvents: function bindEvents() {\n    var eventBus = this.eventBus,\n        _boundEvents = this._boundEvents;\n    _boundEvents.beforePrint = this.beforePrint.bind(this);\n    _boundEvents.afterPrint = this.afterPrint.bind(this);\n    eventBus.on('resize', webViewerResize);\n    eventBus.on('hashchange', webViewerHashchange);\n    eventBus.on('beforeprint', _boundEvents.beforePrint);\n    eventBus.on('afterprint', _boundEvents.afterPrint);\n    eventBus.on('pagerendered', webViewerPageRendered);\n    eventBus.on('textlayerrendered', webViewerTextLayerRendered);\n    eventBus.on('updateviewarea', webViewerUpdateViewarea);\n    eventBus.on('pagechanging', webViewerPageChanging);\n    eventBus.on('scalechanging', webViewerScaleChanging);\n    eventBus.on('rotationchanging', webViewerRotationChanging);\n    eventBus.on('sidebarviewchanged', webViewerSidebarViewChanged);\n    eventBus.on('pagemode', webViewerPageMode);\n    eventBus.on('namedaction', webViewerNamedAction);\n    eventBus.on('presentationmodechanged', webViewerPresentationModeChanged);\n    eventBus.on('presentationmode', webViewerPresentationMode);\n    eventBus.on('openfile', webViewerOpenFile);\n    eventBus.on('print', webViewerPrint);\n    eventBus.on('download', webViewerDownload);\n    eventBus.on('firstpage', webViewerFirstPage);\n    eventBus.on('lastpage', webViewerLastPage);\n    eventBus.on('nextpage', webViewerNextPage);\n    eventBus.on('previouspage', webViewerPreviousPage);\n    eventBus.on('zoomin', webViewerZoomIn);\n    eventBus.on('zoomout', webViewerZoomOut);\n    eventBus.on('zoomreset', webViewerZoomReset);\n    eventBus.on('pagenumberchanged', webViewerPageNumberChanged);\n    eventBus.on('scalechanged', webViewerScaleChanged);\n    eventBus.on('rotatecw', webViewerRotateCw);\n    eventBus.on('rotateccw', webViewerRotateCcw);\n    eventBus.on('switchscrollmode', webViewerSwitchScrollMode);\n    eventBus.on('scrollmodechanged', webViewerScrollModeChanged);\n    eventBus.on('switchspreadmode', webViewerSwitchSpreadMode);\n    eventBus.on('spreadmodechanged', webViewerSpreadModeChanged);\n    eventBus.on('documentproperties', webViewerDocumentProperties);\n    eventBus.on('find', webViewerFind);\n    eventBus.on('findfromurlhash', webViewerFindFromUrlHash);\n    eventBus.on('updatefindmatchescount', webViewerUpdateFindMatchesCount);\n    eventBus.on('updatefindcontrolstate', webViewerUpdateFindControlState);\n\n    if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n      eventBus.on('fileinputchange', webViewerFileInputChange);\n    }\n  },\n  bindWindowEvents: function bindWindowEvents() {\n    var eventBus = this.eventBus,\n        _boundEvents = this._boundEvents;\n\n    _boundEvents.windowResize = function () {\n      eventBus.dispatch('resize', {\n        source: window\n      });\n    };\n\n    _boundEvents.windowHashChange = function () {\n      eventBus.dispatch('hashchange', {\n        source: window,\n        hash: document.location.hash.substring(1)\n      });\n    };\n\n    _boundEvents.windowBeforePrint = function () {\n      eventBus.dispatch('beforeprint', {\n        source: window\n      });\n    };\n\n    _boundEvents.windowAfterPrint = function () {\n      eventBus.dispatch('afterprint', {\n        source: window\n      });\n    };\n\n    window.addEventListener('visibilitychange', webViewerVisibilityChange);\n    window.addEventListener('wheel', webViewerWheel, {\n      passive: false\n    });\n    window.addEventListener('click', webViewerClick);\n    window.addEventListener('keydown', webViewerKeyDown);\n    window.addEventListener('resize', _boundEvents.windowResize);\n    window.addEventListener('hashchange', _boundEvents.windowHashChange);\n    window.addEventListener('beforeprint', _boundEvents.windowBeforePrint);\n    window.addEventListener('afterprint', _boundEvents.windowAfterPrint);\n  },\n  unbindEvents: function unbindEvents() {\n    var eventBus = this.eventBus,\n        _boundEvents = this._boundEvents;\n    eventBus.off('resize', webViewerResize);\n    eventBus.off('hashchange', webViewerHashchange);\n    eventBus.off('beforeprint', _boundEvents.beforePrint);\n    eventBus.off('afterprint', _boundEvents.afterPrint);\n    eventBus.off('pagerendered', webViewerPageRendered);\n    eventBus.off('textlayerrendered', webViewerTextLayerRendered);\n    eventBus.off('updateviewarea', webViewerUpdateViewarea);\n    eventBus.off('pagechanging', webViewerPageChanging);\n    eventBus.off('scalechanging', webViewerScaleChanging);\n    eventBus.off('rotationchanging', webViewerRotationChanging);\n    eventBus.off('sidebarviewchanged', webViewerSidebarViewChanged);\n    eventBus.off('pagemode', webViewerPageMode);\n    eventBus.off('namedaction', webViewerNamedAction);\n    eventBus.off('presentationmodechanged', webViewerPresentationModeChanged);\n    eventBus.off('presentationmode', webViewerPresentationMode);\n    eventBus.off('openfile', webViewerOpenFile);\n    eventBus.off('print', webViewerPrint);\n    eventBus.off('download', webViewerDownload);\n    eventBus.off('firstpage', webViewerFirstPage);\n    eventBus.off('lastpage', webViewerLastPage);\n    eventBus.off('nextpage', webViewerNextPage);\n    eventBus.off('previouspage', webViewerPreviousPage);\n    eventBus.off('zoomin', webViewerZoomIn);\n    eventBus.off('zoomout', webViewerZoomOut);\n    eventBus.off('zoomreset', webViewerZoomReset);\n    eventBus.off('pagenumberchanged', webViewerPageNumberChanged);\n    eventBus.off('scalechanged', webViewerScaleChanged);\n    eventBus.off('rotatecw', webViewerRotateCw);\n    eventBus.off('rotateccw', webViewerRotateCcw);\n    eventBus.off('switchscrollmode', webViewerSwitchScrollMode);\n    eventBus.off('scrollmodechanged', webViewerScrollModeChanged);\n    eventBus.off('switchspreadmode', webViewerSwitchSpreadMode);\n    eventBus.off('spreadmodechanged', webViewerSpreadModeChanged);\n    eventBus.off('documentproperties', webViewerDocumentProperties);\n    eventBus.off('find', webViewerFind);\n    eventBus.off('findfromurlhash', webViewerFindFromUrlHash);\n    eventBus.off('updatefindmatchescount', webViewerUpdateFindMatchesCount);\n    eventBus.off('updatefindcontrolstate', webViewerUpdateFindControlState);\n\n    if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n      eventBus.off('fileinputchange', webViewerFileInputChange);\n    }\n\n    _boundEvents.beforePrint = null;\n    _boundEvents.afterPrint = null;\n  },\n  unbindWindowEvents: function unbindWindowEvents() {\n    var _boundEvents = this._boundEvents;\n    window.removeEventListener('visibilitychange', webViewerVisibilityChange);\n    window.removeEventListener('wheel', webViewerWheel);\n    window.removeEventListener('click', webViewerClick);\n    window.removeEventListener('keydown', webViewerKeyDown);\n    window.removeEventListener('resize', _boundEvents.windowResize);\n    window.removeEventListener('hashchange', _boundEvents.windowHashChange);\n    window.removeEventListener('beforeprint', _boundEvents.windowBeforePrint);\n    window.removeEventListener('afterprint', _boundEvents.windowAfterPrint);\n    _boundEvents.windowResize = null;\n    _boundEvents.windowHashChange = null;\n    _boundEvents.windowBeforePrint = null;\n    _boundEvents.windowAfterPrint = null;\n  }\n};\nexports.PDFViewerApplication = PDFViewerApplication;\nvar validateFileURL;\n\nif (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n  var HOSTED_VIEWER_ORIGINS = ['null', 'http://mozilla.github.io', 'https://mozilla.github.io'];\n\n  validateFileURL = function validateFileURL(file) {\n    if (file === undefined) {\n      return;\n    }\n\n    try {\n      var viewerOrigin = new URL(window.location.href).origin || 'null';\n\n      if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) {\n        // Hosted or local viewer, allow for any file locations\n        return;\n      }\n\n      var _ref8 = new URL(file, window.location.href),\n          origin = _ref8.origin,\n          protocol = _ref8.protocol; // Removing of the following line will not guarantee that the viewer will\n      // start accepting URLs from foreign origin -- CORS headers on the remote\n      // server must be properly configured.\n      // IE10 / IE11 does not include an origin in `blob:`-URLs. So don't block\n      // any blob:-URL. The browser's same-origin policy will block requests to\n      // blob:-URLs from other origins, so this is safe.\n\n\n      if (origin !== viewerOrigin && protocol !== 'blob:') {\n        //throw new Error('file origin does not match viewer\\'s');\n        console.log('file origin does not match viewer\\'s');\n      }\n    } catch (ex) {\n      var message = ex && ex.message;\n      PDFViewerApplication.l10n.get('loading_error', null, 'An error occurred while loading the PDF.').then(function (loadingErrorMessage) {\n        PDFViewerApplication.error(loadingErrorMessage, {\n          message: message\n        });\n      });\n      throw ex;\n    }\n  };\n}\n\nfunction loadFakeWorker() {\n  if (!_pdfjsDist.GlobalWorkerOptions.workerSrc) {\n    _pdfjsDist.GlobalWorkerOptions.workerSrc = _app_options.AppOptions.get('workerSrc');\n  }\n\n  if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('PRODUCTION')) {\n    return new Promise(function (resolve, reject) {\n      if ((typeof SystemJS === \"undefined\" ? \"undefined\" : _typeof(SystemJS)) === 'object') {\n        SystemJS.import('pdfjs/core/worker').then(function (worker) {\n          window.pdfjsWorker = worker;\n          resolve();\n        }).catch(reject);\n      } else if (typeof require === 'function') {\n        try {\n          window.pdfjsWorker = require('../src/core/worker.js');\n          resolve();\n        } catch (ex) {\n          reject(ex);\n        }\n      } else {\n        reject(new Error('SystemJS or CommonJS must be used to load fake worker.'));\n      }\n    });\n  }\n\n  return (0, _pdfjsDist.loadScript)(_pdfjsDist.PDFWorker.getWorkerSrc());\n}\n\nfunction loadAndEnablePDFBug(enabledTabs) {\n  var appConfig = PDFViewerApplication.appConfig;\n  return (0, _pdfjsDist.loadScript)(appConfig.debuggerScriptPath).then(function () {\n    PDFBug.enable(enabledTabs);\n    PDFBug.init({\n      OPS: _pdfjsDist.OPS,\n      createObjectURL: _pdfjsDist.createObjectURL\n    }, appConfig.mainContainer);\n  });\n}\n\nfunction webViewerInitialized() {\n  var appConfig = PDFViewerApplication.appConfig;\n  var file;\n\n  if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n    var queryString = document.location.search.substring(1); // let params = parseQueryString(queryString);\n    // file = 'file' in params ? params.file : AppOptions.get('defaultUrl');\n\n    file = window.vue.$route.query['file'] ? window.vue.$route.query['file'] : _app_options.AppOptions.get('defaultUrl');\n    validateFileURL(file);\n  } else if (PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n    file = window.location.href.split('#')[0];\n  } else if (PDFJSDev.test('CHROME')) {\n    file = _app_options.AppOptions.get('defaultUrl');\n  }\n\n  if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n    var fileInput = document.createElement('input');\n    fileInput.id = appConfig.openFileInputName;\n    fileInput.className = 'fileInput';\n    fileInput.setAttribute('type', 'file');\n    fileInput.oncontextmenu = _ui_utils.noContextMenuHandler;\n    document.body.appendChild(fileInput);\n\n    if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {\n      appConfig.toolbar.openFile.setAttribute('hidden', 'true');\n      appConfig.secondaryToolbar.openFileButton.setAttribute('hidden', 'true');\n    } else {\n      fileInput.value = null;\n    }\n\n    fileInput.addEventListener('change', function (evt) {\n      var files = evt.target.files;\n\n      if (!files || files.length === 0) {\n        return;\n      }\n\n      PDFViewerApplication.eventBus.dispatch('fileinputchange', {\n        source: this,\n        fileInput: evt.target\n      });\n    }); // Enable draging-and-dropping a new PDF file onto the viewerContainer.\n\n    appConfig.mainContainer.addEventListener('dragover', function (evt) {\n      evt.preventDefault();\n      evt.dataTransfer.dropEffect = 'move';\n    });\n    appConfig.mainContainer.addEventListener('drop', function (evt) {\n      evt.preventDefault();\n      var files = evt.dataTransfer.files;\n\n      if (!files || files.length === 0) {\n        return;\n      }\n\n      PDFViewerApplication.eventBus.dispatch('fileinputchange', {\n        source: this,\n        fileInput: evt.dataTransfer\n      });\n    });\n  } else {\n    appConfig.toolbar.openFile.setAttribute('hidden', 'true');\n    appConfig.secondaryToolbar.openFileButton.setAttribute('hidden', 'true');\n  }\n\n  if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('FIREFOX || MOZCENTRAL') && !PDFViewerApplication.supportsDocumentFonts) {\n    _app_options.AppOptions.set('disableFontFace', true);\n\n    PDFViewerApplication.l10n.get('web_fonts_disabled', null, 'Web fonts are disabled: unable to use embedded PDF fonts.').then(function (msg) {\n      console.warn(msg);\n    });\n  }\n\n  if (!PDFViewerApplication.supportsPrinting) {\n    appConfig.toolbar.print.classList.add('hidden');\n    appConfig.secondaryToolbar.printButton.classList.add('hidden');\n  }\n\n  if (!PDFViewerApplication.supportsFullscreen) {\n    appConfig.toolbar.presentationModeButton.classList.add('hidden');\n    appConfig.secondaryToolbar.presentationModeButton.classList.add('hidden');\n  }\n\n  if (PDFViewerApplication.supportsIntegratedFind) {\n    appConfig.toolbar.viewFind.classList.add('hidden');\n  }\n\n  appConfig.mainContainer.addEventListener('transitionend', function (evt) {\n    if (evt.target ===\n    /* mainContainer */\n    this) {\n      PDFViewerApplication.eventBus.dispatch('resize', {\n        source: this\n      });\n    }\n  }, true);\n\n  try {\n    webViewerOpenFileViaURL(file);\n  } catch (reason) {\n    PDFViewerApplication.l10n.get('loading_error', null, 'An error occurred while loading the PDF.').then(function (msg) {\n      PDFViewerApplication.error(msg, reason);\n    });\n  }\n}\n\nvar webViewerOpenFileViaURL;\n\nif (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n  webViewerOpenFileViaURL = function webViewerOpenFileViaURL(file) {\n    if (file && file.lastIndexOf('file:', 0) === 0) {\n      // file:-scheme. Load the contents in the main thread because QtWebKit\n      // cannot load file:-URLs in a Web Worker. file:-URLs are usually loaded\n      // very quickly, so there is no need to set up progress event listeners.\n      PDFViewerApplication.setTitleUsingUrl(file);\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function () {\n        PDFViewerApplication.open(new Uint8Array(xhr.response));\n      };\n\n      xhr.open('GET', file);\n      xhr.responseType = 'arraybuffer';\n      xhr.send();\n      return;\n    }\n\n    if (file) {\n      PDFViewerApplication.open(file);\n    }\n  };\n} else if (PDFJSDev.test('FIREFOX || MOZCENTRAL || CHROME')) {\n  webViewerOpenFileViaURL = function webViewerOpenFileViaURL(file) {\n    PDFViewerApplication.setTitleUsingUrl(file);\n    PDFViewerApplication.initPassiveLoading();\n  };\n} else {\n  webViewerOpenFileViaURL = function webViewerOpenFileViaURL(file) {\n    if (file) {\n      throw new Error('Not implemented: webViewerOpenFileViaURL');\n    }\n  };\n}\n\nfunction webViewerPageRendered(evt) {\n  var pageNumber = evt.pageNumber;\n  var pageIndex = pageNumber - 1;\n  var pageView = PDFViewerApplication.pdfViewer.getPageView(pageIndex); // If the page is still visible when it has finished rendering,\n  // ensure that the page number input loading indicator is hidden.\n\n  if (pageNumber === PDFViewerApplication.page) {\n    PDFViewerApplication.toolbar.updateLoadingIndicatorState(false);\n  } // Prevent errors in the edge-case where the PDF document is removed *before*\n  // the 'pagerendered' event handler is invoked.\n\n\n  if (!pageView) {\n    return;\n  } // Use the rendered page to set the corresponding thumbnail image.\n\n\n  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {\n    var thumbnailView = PDFViewerApplication.pdfThumbnailViewer.getThumbnail(pageIndex);\n    thumbnailView.setImage(pageView);\n  }\n\n  if (typeof Stats !== 'undefined' && Stats.enabled && pageView.stats) {\n    Stats.add(pageNumber, pageView.stats);\n  }\n\n  if (pageView.error) {\n    PDFViewerApplication.l10n.get('rendering_error', null, 'An error occurred while rendering the page.').then(function (msg) {\n      PDFViewerApplication.error(msg, pageView.error);\n    });\n  }\n\n  if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n    PDFViewerApplication.externalServices.reportTelemetry({\n      type: 'pageInfo',\n      timestamp: evt.timestamp\n    }); // It is a good time to report stream and font types.\n\n    PDFViewerApplication.pdfDocument.getStats().then(function (stats) {\n      PDFViewerApplication.externalServices.reportTelemetry({\n        type: 'documentStats',\n        stats: stats\n      });\n    });\n  }\n}\n\nfunction webViewerTextLayerRendered(evt) {\n  if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('FIREFOX || MOZCENTRAL') && evt.numTextDivs > 0 && !PDFViewerApplication.supportsDocumentColors) {\n    PDFViewerApplication.l10n.get('document_colors_not_allowed', null, 'PDF documents are not allowed to use their own colors: ' + '\\'Allow pages to choose their own colors\\' ' + 'is deactivated in the browser.').then(function (msg) {\n      console.error(msg);\n    });\n    PDFViewerApplication.fallback();\n  }\n}\n\nfunction webViewerPageMode(evt) {\n  // Handle the 'pagemode' hash parameter, see also `PDFLinkService_setHash`.\n  var mode = evt.mode,\n      view;\n\n  switch (mode) {\n    case 'thumbs':\n      view = _pdf_sidebar.SidebarView.THUMBS;\n      break;\n\n    case 'bookmarks':\n    case 'outline':\n      view = _pdf_sidebar.SidebarView.OUTLINE;\n      break;\n\n    case 'attachments':\n      view = _pdf_sidebar.SidebarView.ATTACHMENTS;\n      break;\n\n    case 'none':\n      view = _pdf_sidebar.SidebarView.NONE;\n      break;\n\n    default:\n      console.error('Invalid \"pagemode\" hash parameter: ' + mode);\n      return;\n  }\n\n  PDFViewerApplication.pdfSidebar.switchView(view,\n  /* forceOpen = */\n  true);\n}\n\nfunction webViewerNamedAction(evt) {\n  // Processing couple of named actions that might be useful.\n  // See also PDFLinkService.executeNamedAction\n  var action = evt.action;\n\n  switch (action) {\n    case 'GoToPage':\n      PDFViewerApplication.appConfig.toolbar.pageNumber.select();\n      break;\n\n    case 'Find':\n      if (!PDFViewerApplication.supportsIntegratedFind) {\n        PDFViewerApplication.findBar.toggle();\n      }\n\n      break;\n  }\n}\n\nfunction webViewerPresentationModeChanged(evt) {\n  var active = evt.active,\n      switchInProgress = evt.switchInProgress;\n  PDFViewerApplication.pdfViewer.presentationModeState = switchInProgress ? _ui_utils.PresentationModeState.CHANGING : active ? _ui_utils.PresentationModeState.FULLSCREEN : _ui_utils.PresentationModeState.NORMAL;\n}\n\nfunction webViewerSidebarViewChanged(evt) {\n  PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = PDFViewerApplication.pdfSidebar.isThumbnailViewVisible;\n  var store = PDFViewerApplication.store;\n\n  if (store && PDFViewerApplication.isInitialViewSet) {\n    // Only update the storage when the document has been loaded *and* rendered.\n    store.set('sidebarView', evt.view).catch(function () {});\n  }\n}\n\nfunction webViewerUpdateViewarea(evt) {\n  var location = evt.location,\n      store = PDFViewerApplication.store;\n\n  if (store && PDFViewerApplication.isInitialViewSet) {\n    store.setMultiple({\n      'page': location.pageNumber,\n      'zoom': location.scale,\n      'scrollLeft': location.left,\n      'scrollTop': location.top,\n      'rotation': location.rotation\n    }).catch(function () {\n      /* unable to write to storage */\n    });\n  }\n\n  var href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams);\n  PDFViewerApplication.appConfig.toolbar.viewBookmark.href = href;\n  PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href; // Show/hide the loading indicator in the page number input element.\n\n  var currentPage = PDFViewerApplication.pdfViewer.getPageView(PDFViewerApplication.page - 1);\n  var loading = currentPage.renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED;\n  PDFViewerApplication.toolbar.updateLoadingIndicatorState(loading);\n}\n\nfunction webViewerScrollModeChanged(evt) {\n  var store = PDFViewerApplication.store;\n\n  if (store && PDFViewerApplication.isInitialViewSet) {\n    // Only update the storage when the document has been loaded *and* rendered.\n    store.set('scrollMode', evt.mode).catch(function () {});\n  }\n}\n\nfunction webViewerSpreadModeChanged(evt) {\n  var store = PDFViewerApplication.store;\n\n  if (store && PDFViewerApplication.isInitialViewSet) {\n    // Only update the storage when the document has been loaded *and* rendered.\n    store.set('spreadMode', evt.mode).catch(function () {});\n  }\n}\n\nfunction webViewerResize() {\n  var pdfDocument = PDFViewerApplication.pdfDocument,\n      pdfViewer = PDFViewerApplication.pdfViewer;\n\n  if (!pdfDocument) {\n    return;\n  }\n\n  var currentScaleValue = pdfViewer.currentScaleValue;\n\n  if (currentScaleValue === 'auto' || currentScaleValue === 'page-fit' || currentScaleValue === 'page-width') {\n    // Note: the scale is constant for 'page-actual'.\n    pdfViewer.currentScaleValue = currentScaleValue;\n  }\n\n  pdfViewer.update();\n}\n\nfunction webViewerHashchange(evt) {\n  var hash = evt.hash;\n\n  if (!hash) {\n    return;\n  }\n\n  if (!PDFViewerApplication.isInitialViewSet) {\n    PDFViewerApplication.initialBookmark = hash;\n  } else if (!PDFViewerApplication.pdfHistory.popStateInProgress) {\n    PDFViewerApplication.pdfLinkService.setHash(hash);\n  }\n}\n\nvar webViewerFileInputChange;\n\nif (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n  webViewerFileInputChange = function webViewerFileInputChange(evt) {\n    if (PDFViewerApplication.pdfViewer && PDFViewerApplication.pdfViewer.isInPresentationMode) {\n      return; // Opening a new PDF file isn't supported in Presentation Mode.\n    }\n\n    var file = evt.fileInput.files[0];\n\n    if (URL.createObjectURL && !_app_options.AppOptions.get('disableCreateObjectURL')) {\n      var url = URL.createObjectURL(file);\n\n      if (file.name) {\n        url = {\n          url: url,\n          originalUrl: file.name\n        };\n      }\n\n      PDFViewerApplication.open(url);\n    } else {\n      PDFViewerApplication.setTitleUsingUrl(file.name); // Read the local file into a Uint8Array.\n\n      var fileReader = new FileReader();\n\n      fileReader.onload = function webViewerChangeFileReaderOnload(evt) {\n        var buffer = evt.target.result;\n        PDFViewerApplication.open(new Uint8Array(buffer));\n      };\n\n      fileReader.readAsArrayBuffer(file);\n    } // URL does not reflect proper document location - hiding some icons.\n\n\n    var appConfig = PDFViewerApplication.appConfig;\n    appConfig.toolbar.viewBookmark.setAttribute('hidden', 'true');\n    appConfig.secondaryToolbar.viewBookmarkButton.setAttribute('hidden', 'true');\n    appConfig.toolbar.download.setAttribute('hidden', 'true');\n    appConfig.secondaryToolbar.downloadButton.setAttribute('hidden', 'true');\n  };\n}\n\nfunction webViewerPresentationMode() {\n  PDFViewerApplication.requestPresentationMode();\n}\n\nfunction webViewerOpenFile() {\n  if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('GENERIC')) {\n    var openFileInputName = PDFViewerApplication.appConfig.openFileInputName;\n    document.getElementById(openFileInputName).click();\n  }\n}\n\nfunction webViewerPrint() {\n  window.print();\n}\n\nfunction webViewerDownload() {\n  PDFViewerApplication.download();\n}\n\nfunction webViewerFirstPage() {\n  if (PDFViewerApplication.pdfDocument) {\n    PDFViewerApplication.page = 1;\n  }\n}\n\nfunction webViewerLastPage() {\n  if (PDFViewerApplication.pdfDocument) {\n    PDFViewerApplication.page = PDFViewerApplication.pagesCount;\n  }\n}\n\nfunction webViewerNextPage() {\n  PDFViewerApplication.page++;\n}\n\nfunction webViewerPreviousPage() {\n  PDFViewerApplication.page--;\n}\n\nfunction webViewerZoomIn() {\n  PDFViewerApplication.zoomIn();\n}\n\nfunction webViewerZoomOut() {\n  PDFViewerApplication.zoomOut();\n}\n\nfunction webViewerZoomReset() {\n  PDFViewerApplication.zoomReset();\n}\n\nfunction webViewerPageNumberChanged(evt) {\n  var pdfViewer = PDFViewerApplication.pdfViewer; // Note that for `<input type=\"number\">` HTML elements, an empty string will\n  // be returned for non-number inputs; hence we simply do nothing in that case.\n\n  if (evt.value !== '') {\n    pdfViewer.currentPageLabel = evt.value;\n  } // Ensure that the page number input displays the correct value, even if the\n  // value entered by the user was invalid (e.g. a floating point number).\n\n\n  if (evt.value !== pdfViewer.currentPageNumber.toString() && evt.value !== pdfViewer.currentPageLabel) {\n    PDFViewerApplication.toolbar.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel);\n  }\n}\n\nfunction webViewerScaleChanged(evt) {\n  PDFViewerApplication.pdfViewer.currentScaleValue = evt.value;\n}\n\nfunction webViewerRotateCw() {\n  PDFViewerApplication.rotatePages(90);\n}\n\nfunction webViewerRotateCcw() {\n  PDFViewerApplication.rotatePages(-90);\n}\n\nfunction webViewerSwitchScrollMode(evt) {\n  PDFViewerApplication.pdfViewer.scrollMode = evt.mode;\n}\n\nfunction webViewerSwitchSpreadMode(evt) {\n  PDFViewerApplication.pdfViewer.spreadMode = evt.mode;\n}\n\nfunction webViewerDocumentProperties() {\n  PDFViewerApplication.pdfDocumentProperties.open();\n}\n\nfunction webViewerFind(evt) {\n  PDFViewerApplication.findController.executeCommand('find' + evt.type, {\n    query: evt.query,\n    phraseSearch: evt.phraseSearch,\n    caseSensitive: evt.caseSensitive,\n    entireWord: evt.entireWord,\n    highlightAll: evt.highlightAll,\n    findPrevious: evt.findPrevious\n  });\n}\n\nfunction webViewerFindFromUrlHash(evt) {\n  PDFViewerApplication.findController.executeCommand('find', {\n    query: evt.query,\n    phraseSearch: evt.phraseSearch,\n    caseSensitive: false,\n    entireWord: false,\n    highlightAll: true,\n    findPrevious: false\n  });\n}\n\nfunction webViewerUpdateFindMatchesCount(_ref9) {\n  var matchesCount = _ref9.matchesCount;\n\n  if (PDFViewerApplication.supportsIntegratedFind) {\n    PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount);\n  } else {\n    PDFViewerApplication.findBar.updateResultsCount(matchesCount);\n  }\n}\n\nfunction webViewerUpdateFindControlState(_ref10) {\n  var state = _ref10.state,\n      previous = _ref10.previous,\n      matchesCount = _ref10.matchesCount;\n\n  if (PDFViewerApplication.supportsIntegratedFind) {\n    PDFViewerApplication.externalServices.updateFindControlState({\n      result: state,\n      findPrevious: previous,\n      matchesCount: matchesCount\n    });\n  } else {\n    PDFViewerApplication.findBar.updateUIState(state, previous, matchesCount);\n  }\n}\n\nfunction webViewerScaleChanging(evt) {\n  PDFViewerApplication.toolbar.setPageScale(evt.presetValue, evt.scale);\n  PDFViewerApplication.pdfViewer.update();\n}\n\nfunction webViewerRotationChanging(evt) {\n  PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation;\n  PDFViewerApplication.forceRendering(); // Ensure that the active page doesn't change during rotation.\n\n  PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber;\n}\n\nfunction webViewerPageChanging(evt) {\n  var page = evt.pageNumber;\n  PDFViewerApplication.toolbar.setPageNumber(page, evt.pageLabel || null);\n  PDFViewerApplication.secondaryToolbar.setPageNumber(page);\n\n  if (PDFViewerApplication.pdfSidebar.isThumbnailViewVisible) {\n    PDFViewerApplication.pdfThumbnailViewer.scrollThumbnailIntoView(page);\n  } // We need to update stats.\n\n\n  if (typeof Stats !== 'undefined' && Stats.enabled) {\n    var pageView = PDFViewerApplication.pdfViewer.getPageView(page - 1);\n\n    if (pageView && pageView.stats) {\n      Stats.add(page, pageView.stats);\n    }\n  }\n}\n\nfunction webViewerVisibilityChange(evt) {\n  if (document.visibilityState === 'visible') {\n    // Ignore mouse wheel zooming during tab switches (bug 1503412).\n    setZoomDisabledTimeout();\n  }\n}\n\nvar zoomDisabledTimeout = null;\n\nfunction setZoomDisabledTimeout() {\n  if (zoomDisabledTimeout) {\n    clearTimeout(zoomDisabledTimeout);\n  }\n\n  zoomDisabledTimeout = setTimeout(function () {\n    zoomDisabledTimeout = null;\n  }, WHEEL_ZOOM_DISABLED_TIMEOUT);\n}\n\nfunction webViewerWheel(evt) {\n  var pdfViewer = PDFViewerApplication.pdfViewer,\n      supportedMouseWheelZoomModifierKeys = PDFViewerApplication.supportedMouseWheelZoomModifierKeys;\n\n  if (pdfViewer.isInPresentationMode) {\n    return;\n  }\n\n  if (evt.ctrlKey && supportedMouseWheelZoomModifierKeys.ctrlKey || evt.metaKey && supportedMouseWheelZoomModifierKeys.metaKey) {\n    // Only zoom the pages, not the entire viewer.\n    evt.preventDefault(); // NOTE: this check must be placed *after* preventDefault.\n\n    if (zoomDisabledTimeout || document.visibilityState === 'hidden') {\n      return;\n    }\n\n    var previousScale = pdfViewer.currentScale;\n    var delta = (0, _ui_utils.normalizeWheelEventDelta)(evt);\n    var MOUSE_WHEEL_DELTA_PER_PAGE_SCALE = 3.0;\n    var ticks = delta * MOUSE_WHEEL_DELTA_PER_PAGE_SCALE;\n\n    if (ticks < 0) {\n      PDFViewerApplication.zoomOut(-ticks);\n    } else {\n      PDFViewerApplication.zoomIn(ticks);\n    }\n\n    var currentScale = pdfViewer.currentScale;\n\n    if (previousScale !== currentScale) {\n      // After scaling the page via zoomIn/zoomOut, the position of the upper-\n      // left corner is restored. When the mouse wheel is used, the position\n      // under the cursor should be restored instead.\n      var scaleCorrectionFactor = currentScale / previousScale - 1;\n      var rect = pdfViewer.container.getBoundingClientRect();\n      var dx = evt.clientX - rect.left;\n      var dy = evt.clientY - rect.top;\n      pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor;\n      pdfViewer.container.scrollTop += dy * scaleCorrectionFactor;\n    }\n  } else {\n    setZoomDisabledTimeout();\n  }\n}\n\nfunction webViewerClick(evt) {\n  if (!PDFViewerApplication.secondaryToolbar.isOpen) {\n    return;\n  }\n\n  var appConfig = PDFViewerApplication.appConfig;\n\n  if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar.container.contains(evt.target) && evt.target !== appConfig.secondaryToolbar.toggleButton) {\n    PDFViewerApplication.secondaryToolbar.close();\n  }\n}\n\nfunction webViewerKeyDown(evt) {\n  if (PDFViewerApplication.overlayManager.active) {\n    return;\n  }\n\n  var handled = false,\n      ensureViewerFocused = false;\n  var cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0);\n  var pdfViewer = PDFViewerApplication.pdfViewer;\n  var isViewerInPresentationMode = pdfViewer && pdfViewer.isInPresentationMode; // First, handle the key bindings that are independent whether an input\n  // control is selected or not.\n\n  if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {\n    // either CTRL or META key with optional SHIFT.\n    switch (evt.keyCode) {\n      case 70:\n        // f\n        if (!PDFViewerApplication.supportsIntegratedFind) {\n          PDFViewerApplication.findBar.open();\n          handled = true;\n        }\n\n        break;\n\n      case 71:\n        // g\n        if (!PDFViewerApplication.supportsIntegratedFind) {\n          var findState = PDFViewerApplication.findController.state;\n\n          if (findState) {\n            PDFViewerApplication.findController.executeCommand('findagain', {\n              query: findState.query,\n              phraseSearch: findState.phraseSearch,\n              caseSensitive: findState.caseSensitive,\n              entireWord: findState.entireWord,\n              highlightAll: findState.highlightAll,\n              findPrevious: cmd === 5 || cmd === 12\n            });\n          }\n\n          handled = true;\n        }\n\n        break;\n\n      case 61: // FF/Mac '='\n\n      case 107: // FF '+' and '='\n\n      case 187: // Chrome '+'\n\n      case 171:\n        // FF with German keyboard\n        if (!isViewerInPresentationMode) {\n          PDFViewerApplication.zoomIn();\n        }\n\n        handled = true;\n        break;\n\n      case 173: // FF/Mac '-'\n\n      case 109: // FF '-'\n\n      case 189:\n        // Chrome '-'\n        if (!isViewerInPresentationMode) {\n          PDFViewerApplication.zoomOut();\n        }\n\n        handled = true;\n        break;\n\n      case 48: // '0'\n\n      case 96:\n        // '0' on Numpad of Swedish keyboard\n        if (!isViewerInPresentationMode) {\n          // keeping it unhandled (to restore page zoom to 100%)\n          setTimeout(function () {\n            // ... and resetting the scale after browser adjusts its scale\n            PDFViewerApplication.zoomReset();\n          });\n          handled = false;\n        }\n\n        break;\n\n      case 38:\n        // up arrow\n        if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {\n          PDFViewerApplication.page = 1;\n          handled = true;\n          ensureViewerFocused = true;\n        }\n\n        break;\n\n      case 40:\n        // down arrow\n        if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {\n          PDFViewerApplication.page = PDFViewerApplication.pagesCount;\n          handled = true;\n          ensureViewerFocused = true;\n        }\n\n        break;\n    }\n  }\n\n  if (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('FIREFOX || MOZCENTRAL')) {\n    // CTRL or META without shift\n    if (cmd === 1 || cmd === 8) {\n      switch (evt.keyCode) {\n        case 83:\n          // s\n          PDFViewerApplication.download();\n          handled = true;\n          break;\n      }\n    }\n  } // CTRL+ALT or Option+Command\n\n\n  if (cmd === 3 || cmd === 10) {\n    switch (evt.keyCode) {\n      case 80:\n        // p\n        PDFViewerApplication.requestPresentationMode();\n        handled = true;\n        break;\n\n      case 71:\n        // g\n        // focuses input#pageNumber field\n        PDFViewerApplication.appConfig.toolbar.pageNumber.select();\n        handled = true;\n        break;\n    }\n  }\n\n  if (handled) {\n    if (ensureViewerFocused && !isViewerInPresentationMode) {\n      pdfViewer.focus();\n    }\n\n    evt.preventDefault();\n    return;\n  } // Some shortcuts should not get handled if a control/input element\n  // is selected.\n\n\n  var curElement = document.activeElement || document.querySelector(':focus');\n  var curElementTagName = curElement && curElement.tagName.toUpperCase();\n\n  if (curElementTagName === 'INPUT' || curElementTagName === 'TEXTAREA' || curElementTagName === 'SELECT' || curElement && curElement.isContentEditable) {\n    // Make sure that the secondary toolbar is closed when Escape is pressed.\n    if (evt.keyCode !== 27) {\n      // 'Esc'\n      return;\n    }\n  }\n\n  if (cmd === 0) {\n    // no control key pressed at all.\n    var turnPage = 0,\n        turnOnlyIfPageFit = false;\n\n    switch (evt.keyCode) {\n      case 38: // up arrow\n\n      case 33:\n        // pg up\n        // vertical scrolling using arrow/pg keys\n        if (pdfViewer.isVerticalScrollbarEnabled) {\n          turnOnlyIfPageFit = true;\n        }\n\n        turnPage = -1;\n        break;\n\n      case 8:\n        // backspace\n        if (!isViewerInPresentationMode) {\n          turnOnlyIfPageFit = true;\n        }\n\n        turnPage = -1;\n        break;\n\n      case 37:\n        // left arrow\n        // horizontal scrolling using arrow keys\n        if (pdfViewer.isHorizontalScrollbarEnabled) {\n          turnOnlyIfPageFit = true;\n        }\n\n      /* falls through */\n\n      case 75: // 'k'\n\n      case 80:\n        // 'p'\n        turnPage = -1;\n        break;\n\n      case 27:\n        // esc key\n        if (PDFViewerApplication.secondaryToolbar.isOpen) {\n          PDFViewerApplication.secondaryToolbar.close();\n          handled = true;\n        }\n\n        if (!PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar.opened) {\n          PDFViewerApplication.findBar.close();\n          handled = true;\n        }\n\n        break;\n\n      case 40: // down arrow\n\n      case 34:\n        // pg down\n        // vertical scrolling using arrow/pg keys\n        if (pdfViewer.isVerticalScrollbarEnabled) {\n          turnOnlyIfPageFit = true;\n        }\n\n        turnPage = 1;\n        break;\n\n      case 13: // enter key\n\n      case 32:\n        // spacebar\n        if (!isViewerInPresentationMode) {\n          turnOnlyIfPageFit = true;\n        }\n\n        turnPage = 1;\n        break;\n\n      case 39:\n        // right arrow\n        // horizontal scrolling using arrow keys\n        if (pdfViewer.isHorizontalScrollbarEnabled) {\n          turnOnlyIfPageFit = true;\n        }\n\n      /* falls through */\n\n      case 74: // 'j'\n\n      case 78:\n        // 'n'\n        turnPage = 1;\n        break;\n\n      case 36:\n        // home\n        if (isViewerInPresentationMode || PDFViewerApplication.page > 1) {\n          PDFViewerApplication.page = 1;\n          handled = true;\n          ensureViewerFocused = true;\n        }\n\n        break;\n\n      case 35:\n        // end\n        if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) {\n          PDFViewerApplication.page = PDFViewerApplication.pagesCount;\n          handled = true;\n          ensureViewerFocused = true;\n        }\n\n        break;\n\n      case 83:\n        // 's'\n        PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.SELECT);\n        break;\n\n      case 72:\n        // 'h'\n        PDFViewerApplication.pdfCursorTools.switchTool(_pdf_cursor_tools.CursorTool.HAND);\n        break;\n\n      case 82:\n        // 'r'\n        PDFViewerApplication.rotatePages(90);\n        break;\n\n      case 115:\n        // F4\n        PDFViewerApplication.pdfSidebar.toggle();\n        break;\n    }\n\n    if (turnPage !== 0 && (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === 'page-fit')) {\n      if (turnPage > 0) {\n        if (PDFViewerApplication.page < PDFViewerApplication.pagesCount) {\n          PDFViewerApplication.page++;\n        }\n      } else {\n        if (PDFViewerApplication.page > 1) {\n          PDFViewerApplication.page--;\n        }\n      }\n\n      handled = true;\n    }\n  }\n\n  if (cmd === 4) {\n    // shift-key\n    switch (evt.keyCode) {\n      case 13: // enter key\n\n      case 32:\n        // spacebar\n        if (!isViewerInPresentationMode && pdfViewer.currentScaleValue !== 'page-fit') {\n          break;\n        }\n\n        if (PDFViewerApplication.page > 1) {\n          PDFViewerApplication.page--;\n        }\n\n        handled = true;\n        break;\n\n      case 82:\n        // 'r'\n        PDFViewerApplication.rotatePages(-90);\n        break;\n    }\n  }\n\n  if (!handled && !isViewerInPresentationMode) {\n    // 33=Page Up  34=Page Down  35=End    36=Home\n    // 37=Left     38=Up         39=Right  40=Down\n    // 32=Spacebar\n    if (evt.keyCode >= 33 && evt.keyCode <= 40 || evt.keyCode === 32 && curElementTagName !== 'BUTTON') {\n      ensureViewerFocused = true;\n    }\n  }\n\n  if (ensureViewerFocused && !pdfViewer.containsElement(curElement)) {\n    // The page container is not focused, but a page navigation key has been\n    // pressed. Change the focus to the viewer container to make sure that\n    // navigation by keyboard works as expected.\n    pdfViewer.focus();\n  }\n\n  if (handled) {\n    evt.preventDefault();\n  }\n}\n/**\n * Converts API PageLayout values to the format used by `PDFViewer`.\n * NOTE: This is supported to the extent that the viewer implements the\n *       necessary Scroll/Spread modes (since SinglePage, TwoPageLeft,\n *       and TwoPageRight all suggests using non-continuous scrolling).\n * @param {string} mode - The API PageLayout value.\n * @returns {number} A value from {SpreadMode}.\n */\n\n\nfunction apiPageLayoutToSpreadMode(layout) {\n  switch (layout) {\n    case 'SinglePage':\n    case 'OneColumn':\n      return _ui_utils.SpreadMode.NONE;\n\n    case 'TwoColumnLeft':\n    case 'TwoPageLeft':\n      return _ui_utils.SpreadMode.ODD;\n\n    case 'TwoColumnRight':\n    case 'TwoPageRight':\n      return _ui_utils.SpreadMode.EVEN;\n  }\n\n  return _ui_utils.SpreadMode.NONE; // Default value.\n}\n/**\n * Converts API PageMode values to the format used by `PDFSidebar`.\n * NOTE: There's also a \"FullScreen\" parameter which is not possible to support,\n *       since the Fullscreen API used in browsers requires that entering\n *       fullscreen mode only occurs as a result of a user-initiated event.\n * @param {string} mode - The API PageMode value.\n * @returns {number} A value from {SidebarView}.\n */\n\n\nfunction apiPageModeToSidebarView(mode) {\n  switch (mode) {\n    case 'UseNone':\n      return _pdf_sidebar.SidebarView.NONE;\n\n    case 'UseThumbs':\n      return _pdf_sidebar.SidebarView.THUMBS;\n\n    case 'UseOutlines':\n      return _pdf_sidebar.SidebarView.OUTLINE;\n\n    case 'UseAttachments':\n      return _pdf_sidebar.SidebarView.ATTACHMENTS;\n\n    case 'UseOC': // Not implemented, since we don't support Optional Content Groups yet.\n\n  }\n\n  return _pdf_sidebar.SidebarView.NONE; // Default value.\n}\n/* Abstract factory for the print service. */\n\n\nvar PDFPrintServiceFactory = {\n  instance: {\n    supportsPrinting: false,\n    createPrintService: function createPrintService() {\n      throw new Error('Not implemented: createPrintService');\n    }\n  }\n};\nexports.PDFPrintServiceFactory = PDFPrintServiceFactory;",null]}