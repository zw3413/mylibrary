{"remainingRequest":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/babel-loader/lib/index.js!/Users/weizhang/JAVASHOP/vue-admin-template-master/src/statics/viewer/pdf/web/pdf_outline_viewer.js","dependencies":[{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/src/statics/viewer/pdf/web/pdf_outline_viewer.js","mtime":1577806166000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFOutlineViewer = void 0;\n\nvar _pdfjsDist = require(\"pdfjs-dist\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULT_TITLE = \"\\u2013\";\n/**\n * @typedef {Object} PDFOutlineViewerOptions\n * @property {HTMLDivElement} container - The viewer element.\n * @property {IPDFLinkService} linkService - The navigation/linking service.\n * @property {EventBus} eventBus - The application event bus.\n */\n\n/**\n * @typedef {Object} PDFOutlineViewerRenderParameters\n * @property {Array|null} outline - An array of outline objects.\n */\n\nvar PDFOutlineViewer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {PDFOutlineViewerOptions} options\n   */\n  function PDFOutlineViewer(_ref) {\n    var container = _ref.container,\n        linkService = _ref.linkService,\n        eventBus = _ref.eventBus;\n\n    _classCallCheck(this, PDFOutlineViewer);\n\n    this.container = container;\n    this.linkService = linkService;\n    this.eventBus = eventBus;\n    this.reset();\n    eventBus.on('toggleoutlinetree', this.toggleOutlineTree.bind(this));\n  }\n\n  _createClass(PDFOutlineViewer, [{\n    key: \"reset\",\n    value: function reset() {\n      this.outline = null;\n      this.lastToggleIsShow = true; // Remove the outline from the DOM.\n\n      this.container.textContent = ''; // Ensure that the left (right in RTL locales) margin is always reset,\n      // to prevent incorrect outline alignment if a new document is opened.\n\n      this.container.classList.remove('outlineWithDeepNesting');\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_dispatchEvent\",\n    value: function _dispatchEvent(outlineCount) {\n      this.eventBus.dispatch('outlineloaded', {\n        source: this,\n        outlineCount: outlineCount\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_bindLink\",\n    value: function _bindLink(element, _ref2) {\n      var url = _ref2.url,\n          newWindow = _ref2.newWindow,\n          dest = _ref2.dest;\n      var linkService = this.linkService;\n\n      if (url) {\n        (0, _pdfjsDist.addLinkAttributes)(element, {\n          url: url,\n          target: newWindow ? _pdfjsDist.LinkTarget.BLANK : linkService.externalLinkTarget,\n          rel: linkService.externalLinkRel,\n          enabled: linkService.externalLinkEnabled\n        });\n        return;\n      }\n\n      element.href = linkService.getDestinationHash(dest);\n\n      element.onclick = function () {\n        if (dest) {\n          linkService.navigateTo(dest);\n        }\n\n        return false;\n      };\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_setStyles\",\n    value: function _setStyles(element, _ref3) {\n      var bold = _ref3.bold,\n          italic = _ref3.italic;\n      var styleStr = '';\n\n      if (bold) {\n        styleStr += 'font-weight: bold;';\n      }\n\n      if (italic) {\n        styleStr += 'font-style: italic;';\n      }\n\n      if (styleStr) {\n        element.setAttribute('style', styleStr);\n      }\n    }\n    /**\n     * Prepend a button before an outline item which allows the user to toggle\n     * the visibility of all outline items at that level.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_addToggleButton\",\n    value: function _addToggleButton(div, _ref4) {\n      var _this = this;\n\n      var count = _ref4.count,\n          items = _ref4.items;\n      var toggler = document.createElement('div');\n      toggler.className = 'outlineItemToggler';\n\n      if (count < 0 && Math.abs(count) === items.length) {\n        toggler.classList.add('outlineItemsHidden');\n      }\n\n      toggler.onclick = function (evt) {\n        evt.stopPropagation();\n        toggler.classList.toggle('outlineItemsHidden');\n\n        if (evt.shiftKey) {\n          var shouldShowAll = !toggler.classList.contains('outlineItemsHidden');\n\n          _this._toggleOutlineItem(div, shouldShowAll);\n        }\n      };\n\n      div.insertBefore(toggler, div.firstChild);\n    }\n    /**\n     * Toggle the visibility of the subtree of an outline item.\n     *\n     * @param {Element} root - the root of the outline (sub)tree.\n     * @param {boolean} show - whether to show the outline (sub)tree. If false,\n     *   the outline subtree rooted at |root| will be collapsed.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_toggleOutlineItem\",\n    value: function _toggleOutlineItem(root) {\n      var show = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.lastToggleIsShow = show;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = root.querySelectorAll('.outlineItemToggler')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var toggler = _step.value;\n          toggler.classList.toggle('outlineItemsHidden', !show);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Collapse or expand all subtrees of the outline.\n     */\n\n  }, {\n    key: \"toggleOutlineTree\",\n    value: function toggleOutlineTree() {\n      if (!this.outline) {\n        return;\n      }\n\n      this._toggleOutlineItem(this.container, !this.lastToggleIsShow);\n    }\n    /**\n     * @param {PDFOutlineViewerRenderParameters} params\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(_ref5) {\n      var outline = _ref5.outline;\n      var outlineCount = 0;\n\n      if (this.outline) {\n        this.reset();\n      }\n\n      this.outline = outline || null;\n\n      if (!outline) {\n        this._dispatchEvent(outlineCount);\n\n        return;\n      }\n\n      var fragment = document.createDocumentFragment();\n      var queue = [{\n        parent: fragment,\n        items: this.outline\n      }];\n      var hasAnyNesting = false;\n\n      while (queue.length > 0) {\n        var levelData = queue.shift();\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = levelData.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var item = _step2.value;\n            var div = document.createElement('div');\n            div.className = 'outlineItem';\n            var element = document.createElement('a');\n\n            this._bindLink(element, item);\n\n            this._setStyles(element, item);\n\n            element.textContent = (0, _pdfjsDist.removeNullCharacters)(item.title) || DEFAULT_TITLE;\n            div.appendChild(element);\n\n            if (item.items.length > 0) {\n              hasAnyNesting = true;\n\n              this._addToggleButton(div, item);\n\n              var itemsDiv = document.createElement('div');\n              itemsDiv.className = 'outlineItems';\n              div.appendChild(itemsDiv);\n              queue.push({\n                parent: itemsDiv,\n                items: item.items\n              });\n            }\n\n            levelData.parent.appendChild(div);\n            outlineCount++;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      if (hasAnyNesting) {\n        this.container.classList.add('outlineWithDeepNesting');\n        this.lastToggleIsShow = fragment.querySelectorAll('.outlineItemsHidden').length === 0;\n      }\n\n      this.container.appendChild(fragment);\n\n      this._dispatchEvent(outlineCount);\n    }\n  }]);\n\n  return PDFOutlineViewer;\n}();\n\nexports.PDFOutlineViewer = PDFOutlineViewer;",null]}