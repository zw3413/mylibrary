{"remainingRequest":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/thread-loader/dist/cjs.js!/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/babel-loader/lib/index.js!/Users/weizhang/JAVASHOP/mylibrary-ui/src/statics/viewer/pdf/src/core/annotation.js","dependencies":[{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/src/statics/viewer/pdf/src/core/annotation.js","mtime":1572199794000},{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["function _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint no-var: error */\nimport { AnnotationBorderStyleType, AnnotationFieldFlag, AnnotationFlag, AnnotationReplyType, AnnotationType, assert, isString, OPS, stringToBytes, stringToPDFString, Util, warn } from '../shared/util';\nimport { Catalog, FileSpec, ObjectLoader } from './obj';\nimport { Dict, isDict, isName, isRef, isStream } from './primitives';\nimport { ColorSpace } from './colorspace';\nimport { getInheritableProperty } from './core_utils';\nimport { OperatorList } from './operator_list';\nimport { Stream } from './stream';\n\nvar AnnotationFactory =\n/*#__PURE__*/\nfunction () {\n  function AnnotationFactory() {\n    _classCallCheck(this, AnnotationFactory);\n  }\n\n  _createClass(AnnotationFactory, null, [{\n    key: \"create\",\n\n    /**\n     * Create an `Annotation` object of the correct type for the given reference\n     * to an annotation dictionary. This yields a promise that is resolved when\n     * the `Annotation` object is constructed.\n     *\n     * @param {XRef} xref\n     * @param {Object} ref\n     * @param {PDFManager} pdfManager\n     * @param {Object} idFactory\n     * @returns {Promise} A promise that is resolved with an {Annotation}\n     *   instance.\n     */\n    value: function create(xref, ref, pdfManager, idFactory) {\n      return pdfManager.ensure(this, '_create', [xref, ref, pdfManager, idFactory]);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_create\",\n    value: function _create(xref, ref, pdfManager, idFactory) {\n      var dict = xref.fetchIfRef(ref);\n\n      if (!isDict(dict)) {\n        return undefined;\n      }\n\n      var id = isRef(ref) ? ref.toString() : \"annot_\".concat(idFactory.createObjId()); // Determine the annotation's subtype.\n\n      var subtype = dict.get('Subtype');\n      subtype = isName(subtype) ? subtype.name : null; // Return the right annotation object based on the subtype and field type.\n\n      var parameters = {\n        xref: xref,\n        dict: dict,\n        subtype: subtype,\n        id: id,\n        pdfManager: pdfManager\n      };\n\n      switch (subtype) {\n        case 'Link':\n          return new LinkAnnotation(parameters);\n\n        case 'Text':\n          return new TextAnnotation(parameters);\n\n        case 'Widget':\n          var fieldType = getInheritableProperty({\n            dict: dict,\n            key: 'FT'\n          });\n          fieldType = isName(fieldType) ? fieldType.name : null;\n\n          switch (fieldType) {\n            case 'Tx':\n              return new TextWidgetAnnotation(parameters);\n\n            case 'Btn':\n              return new ButtonWidgetAnnotation(parameters);\n\n            case 'Ch':\n              return new ChoiceWidgetAnnotation(parameters);\n          }\n\n          warn('Unimplemented widget field type \"' + fieldType + '\", ' + 'falling back to base field type.');\n          return new WidgetAnnotation(parameters);\n\n        case 'Popup':\n          return new PopupAnnotation(parameters);\n\n        case 'FreeText':\n          return new FreeTextAnnotation(parameters);\n\n        case 'Line':\n          return new LineAnnotation(parameters);\n\n        case 'Square':\n          return new SquareAnnotation(parameters);\n\n        case 'Circle':\n          return new CircleAnnotation(parameters);\n\n        case 'PolyLine':\n          return new PolylineAnnotation(parameters);\n\n        case 'Polygon':\n          return new PolygonAnnotation(parameters);\n\n        case 'Caret':\n          return new CaretAnnotation(parameters);\n\n        case 'Ink':\n          return new InkAnnotation(parameters);\n\n        case 'Highlight':\n          return new HighlightAnnotation(parameters);\n\n        case 'Underline':\n          return new UnderlineAnnotation(parameters);\n\n        case 'Squiggly':\n          return new SquigglyAnnotation(parameters);\n\n        case 'StrikeOut':\n          return new StrikeOutAnnotation(parameters);\n\n        case 'Stamp':\n          return new StampAnnotation(parameters);\n\n        case 'FileAttachment':\n          return new FileAttachmentAnnotation(parameters);\n\n        default:\n          if (!subtype) {\n            warn('Annotation is missing the required /Subtype.');\n          } else {\n            warn('Unimplemented annotation type \"' + subtype + '\", ' + 'falling back to base annotation.');\n          }\n\n          return new Annotation(parameters);\n      }\n    }\n  }]);\n\n  return AnnotationFactory;\n}();\n\nfunction getQuadPoints(dict, rect) {\n  if (!dict.has('QuadPoints')) {\n    return null;\n  } // The region is described as a number of quadrilaterals.\n  // Each quadrilateral must consist of eight coordinates.\n\n\n  var quadPoints = dict.getArray('QuadPoints');\n\n  if (!Array.isArray(quadPoints) || quadPoints.length % 8 > 0) {\n    return null;\n  }\n\n  var quadPointsLists = [];\n\n  for (var i = 0, ii = quadPoints.length / 8; i < ii; i++) {\n    // Each series of eight numbers represents the coordinates for one\n    // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].\n    // Convert this to an array of objects with x and y coordinates.\n    quadPointsLists.push([]);\n\n    for (var j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {\n      var x = quadPoints[j];\n      var y = quadPoints[j + 1]; // The quadpoints should be ignored if any coordinate in the array\n      // lies outside the region specified by the rectangle.\n\n      if (x < rect[0] || x > rect[2] || y < rect[1] || y > rect[3]) {\n        return null;\n      }\n\n      quadPointsLists[i].push({\n        x: x,\n        y: y\n      });\n    }\n  }\n\n  return quadPointsLists;\n}\n\nfunction getTransformMatrix(rect, bbox, matrix) {\n  // 12.5.5: Algorithm: Appearance streams\n  var _Util$getAxialAligned = Util.getAxialAlignedBoundingBox(bbox, matrix),\n      _Util$getAxialAligned2 = _slicedToArray(_Util$getAxialAligned, 4),\n      minX = _Util$getAxialAligned2[0],\n      minY = _Util$getAxialAligned2[1],\n      maxX = _Util$getAxialAligned2[2],\n      maxY = _Util$getAxialAligned2[3];\n\n  if (minX === maxX || minY === maxY) {\n    // From real-life file, bbox was [0, 0, 0, 0]. In this case,\n    // just apply the transform for rect\n    return [1, 0, 0, 1, rect[0], rect[1]];\n  }\n\n  var xRatio = (rect[2] - rect[0]) / (maxX - minX);\n  var yRatio = (rect[3] - rect[1]) / (maxY - minY);\n  return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio];\n}\n\nvar Annotation =\n/*#__PURE__*/\nfunction () {\n  function Annotation(params) {\n    _classCallCheck(this, Annotation);\n\n    var dict = params.dict;\n    this.setContents(dict.get('Contents'));\n    this.setModificationDate(dict.get('M'));\n    this.setFlags(dict.get('F'));\n    this.setRectangle(dict.getArray('Rect'));\n    this.setColor(dict.getArray('C'));\n    this.setBorderStyle(dict);\n    this.setAppearance(dict); // Expose public properties using a data object.\n\n    this.data = {\n      annotationFlags: this.flags,\n      borderStyle: this.borderStyle,\n      color: this.color,\n      contents: this.contents,\n      hasAppearance: !!this.appearance,\n      id: params.id,\n      modificationDate: this.modificationDate,\n      rect: this.rectangle,\n      subtype: params.subtype\n    };\n  }\n  /**\n   * @private\n   */\n\n\n  _createClass(Annotation, [{\n    key: \"_hasFlag\",\n    value: function _hasFlag(flags, flag) {\n      return !!(flags & flag);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_isViewable\",\n    value: function _isViewable(flags) {\n      return !this._hasFlag(flags, AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, AnnotationFlag.HIDDEN) && !this._hasFlag(flags, AnnotationFlag.NOVIEW);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_isPrintable\",\n    value: function _isPrintable(flags) {\n      return this._hasFlag(flags, AnnotationFlag.PRINT) && !this._hasFlag(flags, AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, AnnotationFlag.HIDDEN);\n    }\n    /**\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"setContents\",\n\n    /**\n     * Set the contents.\n     *\n     * @public\n     * @memberof Annotation\n     * @param {string} contents - Text to display for the annotation or, if the\n     *                            type of annotation does not display text, a\n     *                            description of the annotation's contents\n     */\n    value: function setContents(contents) {\n      this.contents = stringToPDFString(contents || '');\n    }\n    /**\n     * Set the modification date.\n     *\n     * @public\n     * @memberof Annotation\n     * @param {string} modificationDate - PDF date string that indicates when the\n     *                                    annotation was last modified\n     */\n\n  }, {\n    key: \"setModificationDate\",\n    value: function setModificationDate(modificationDate) {\n      this.modificationDate = isString(modificationDate) ? modificationDate : null;\n    }\n    /**\n     * Set the flags.\n     *\n     * @public\n     * @memberof Annotation\n     * @param {number} flags - Unsigned 32-bit integer specifying annotation\n     *                         characteristics\n     * @see {@link shared/util.js}\n     */\n\n  }, {\n    key: \"setFlags\",\n    value: function setFlags(flags) {\n      this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;\n    }\n    /**\n     * Check if a provided flag is set.\n     *\n     * @public\n     * @memberof Annotation\n     * @param {number} flag - Hexadecimal representation for an annotation\n     *                        characteristic\n     * @returns {boolean}\n     * @see {@link shared/util.js}\n     */\n\n  }, {\n    key: \"hasFlag\",\n    value: function hasFlag(flag) {\n      return this._hasFlag(this.flags, flag);\n    }\n    /**\n     * Set the rectangle.\n     *\n     * @public\n     * @memberof Annotation\n     * @param {Array} rectangle - The rectangle array with exactly four entries\n     */\n\n  }, {\n    key: \"setRectangle\",\n    value: function setRectangle(rectangle) {\n      if (Array.isArray(rectangle) && rectangle.length === 4) {\n        this.rectangle = Util.normalizeRect(rectangle);\n      } else {\n        this.rectangle = [0, 0, 0, 0];\n      }\n    }\n    /**\n     * Set the color and take care of color space conversion.\n     * The default value is black, in RGB color space.\n     *\n     * @public\n     * @memberof Annotation\n     * @param {Array} color - The color array containing either 0\n     *                        (transparent), 1 (grayscale), 3 (RGB) or\n     *                        4 (CMYK) elements\n     */\n\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      var rgbColor = new Uint8ClampedArray(3);\n\n      if (!Array.isArray(color)) {\n        this.color = rgbColor;\n        return;\n      }\n\n      switch (color.length) {\n        case 0:\n          // Transparent, which we indicate with a null value\n          this.color = null;\n          break;\n\n        case 1:\n          // Convert grayscale to RGB\n          ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);\n          this.color = rgbColor;\n          break;\n\n        case 3:\n          // Convert RGB percentages to RGB\n          ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);\n          this.color = rgbColor;\n          break;\n\n        case 4:\n          // Convert CMYK to RGB\n          ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);\n          this.color = rgbColor;\n          break;\n\n        default:\n          this.color = rgbColor;\n          break;\n      }\n    }\n    /**\n     * Set the border style (as AnnotationBorderStyle object).\n     *\n     * @public\n     * @memberof Annotation\n     * @param {Dict} borderStyle - The border style dictionary\n     */\n\n  }, {\n    key: \"setBorderStyle\",\n    value: function setBorderStyle(borderStyle) {\n      if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('!PRODUCTION || TESTING')) {\n        assert(this.rectangle, 'setRectangle must have been called previously.');\n      }\n\n      this.borderStyle = new AnnotationBorderStyle();\n\n      if (!isDict(borderStyle)) {\n        return;\n      }\n\n      if (borderStyle.has('BS')) {\n        var dict = borderStyle.get('BS');\n        var dictType = dict.get('Type');\n\n        if (!dictType || isName(dictType, 'Border')) {\n          this.borderStyle.setWidth(dict.get('W'), this.rectangle);\n          this.borderStyle.setStyle(dict.get('S'));\n          this.borderStyle.setDashArray(dict.getArray('D'));\n        }\n      } else if (borderStyle.has('Border')) {\n        var array = borderStyle.getArray('Border');\n\n        if (Array.isArray(array) && array.length >= 3) {\n          this.borderStyle.setHorizontalCornerRadius(array[0]);\n          this.borderStyle.setVerticalCornerRadius(array[1]);\n          this.borderStyle.setWidth(array[2], this.rectangle);\n\n          if (array.length === 4) {\n            // Dash array available\n            this.borderStyle.setDashArray(array[3]);\n          }\n        }\n      } else {\n        // There are no border entries in the dictionary. According to the\n        // specification, we should draw a solid border of width 1 in that\n        // case, but Adobe Reader did not implement that part of the\n        // specification and instead draws no border at all, so we do the same.\n        // See also https://github.com/mozilla/pdf.js/issues/6179.\n        this.borderStyle.setWidth(0);\n      }\n    }\n    /**\n     * Set the (normal) appearance.\n     *\n     * @public\n     * @memberof Annotation\n     * @param {Dict} dict - The annotation's data dictionary\n     */\n\n  }, {\n    key: \"setAppearance\",\n    value: function setAppearance(dict) {\n      this.appearance = null;\n      var appearanceStates = dict.get('AP');\n\n      if (!isDict(appearanceStates)) {\n        return;\n      } // In case the normal appearance is a stream, then it is used directly.\n\n\n      var normalAppearanceState = appearanceStates.get('N');\n\n      if (isStream(normalAppearanceState)) {\n        this.appearance = normalAppearanceState;\n        return;\n      }\n\n      if (!isDict(normalAppearanceState)) {\n        return;\n      } // In case the normal appearance is a dictionary, the `AS` entry provides\n      // the key of the stream in this dictionary.\n\n\n      var as = dict.get('AS');\n\n      if (!isName(as) || !normalAppearanceState.has(as.name)) {\n        return;\n      }\n\n      this.appearance = normalAppearanceState.get(as.name);\n    }\n  }, {\n    key: \"loadResources\",\n    value: function loadResources(keys) {\n      return this.appearance.dict.getAsync('Resources').then(function (resources) {\n        if (!resources) {\n          return undefined;\n        }\n\n        var objectLoader = new ObjectLoader(resources, keys, resources.xref);\n        return objectLoader.load().then(function () {\n          return resources;\n        });\n      });\n    }\n  }, {\n    key: \"getOperatorList\",\n    value: function getOperatorList(evaluator, task, renderForms) {\n      var _this = this;\n\n      if (!this.appearance) {\n        return Promise.resolve(new OperatorList());\n      }\n\n      var data = this.data;\n      var appearanceDict = this.appearance.dict;\n      var resourcesPromise = this.loadResources(['ExtGState', 'ColorSpace', 'Pattern', 'Shading', 'XObject', 'Font']);\n      var bbox = appearanceDict.getArray('BBox') || [0, 0, 1, 1];\n      var matrix = appearanceDict.getArray('Matrix') || [1, 0, 0, 1, 0, 0];\n      var transform = getTransformMatrix(data.rect, bbox, matrix);\n      return resourcesPromise.then(function (resources) {\n        var opList = new OperatorList();\n        opList.addOp(OPS.beginAnnotation, [data.rect, transform, matrix]);\n        return evaluator.getOperatorList({\n          stream: _this.appearance,\n          task: task,\n          resources: resources,\n          operatorList: opList\n        }).then(function () {\n          opList.addOp(OPS.endAnnotation, []);\n\n          _this.appearance.reset();\n\n          return opList;\n        });\n      });\n    }\n  }, {\n    key: \"viewable\",\n    get: function get() {\n      if (this.flags === 0) {\n        return true;\n      }\n\n      return this._isViewable(this.flags);\n    }\n    /**\n     * @type {boolean}\n     */\n\n  }, {\n    key: \"printable\",\n    get: function get() {\n      if (this.flags === 0) {\n        return false;\n      }\n\n      return this._isPrintable(this.flags);\n    }\n  }]);\n\n  return Annotation;\n}();\n/**\n * Contains all data regarding an annotation's border style.\n */\n\n\nvar AnnotationBorderStyle =\n/*#__PURE__*/\nfunction () {\n  function AnnotationBorderStyle() {\n    _classCallCheck(this, AnnotationBorderStyle);\n\n    this.width = 1;\n    this.style = AnnotationBorderStyleType.SOLID;\n    this.dashArray = [3];\n    this.horizontalCornerRadius = 0;\n    this.verticalCornerRadius = 0;\n  }\n  /**\n   * Set the width.\n   *\n   * @public\n   * @memberof AnnotationBorderStyle\n   * @param {number} width - The width.\n   * @param {Array} rect - The annotation `Rect` entry.\n   */\n\n\n  _createClass(AnnotationBorderStyle, [{\n    key: \"setWidth\",\n    value: function setWidth(width) {\n      var rect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0];\n\n      if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('!PRODUCTION || TESTING')) {\n        assert(Array.isArray(rect) && rect.length === 4, 'A valid `rect` parameter must be provided.');\n      } // Some corrupt PDF generators may provide the width as a `Name`,\n      // rather than as a number (fixes issue 10385).\n\n\n      if (isName(width)) {\n        this.width = 0; // This is consistent with the behaviour in Adobe Reader.\n\n        return;\n      }\n\n      if (Number.isInteger(width)) {\n        if (width > 0) {\n          var maxWidth = (rect[2] - rect[0]) / 2;\n          var maxHeight = (rect[3] - rect[1]) / 2; // Ignore large `width`s, since they lead to the Annotation overflowing\n          // the size set by the `Rect` entry thus causing the `annotationLayer`\n          // to render it over the surrounding document (fixes bug1552113.pdf).\n\n          if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) {\n            warn(\"AnnotationBorderStyle.setWidth - ignoring width: \".concat(width));\n            width = 1;\n          }\n        }\n\n        this.width = width;\n      }\n    }\n    /**\n     * Set the style.\n     *\n     * @public\n     * @memberof AnnotationBorderStyle\n     * @param {Name} style - The annotation style.\n     * @see {@link shared/util.js}\n     */\n\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(style) {\n      if (!isName(style)) {\n        return;\n      }\n\n      switch (style.name) {\n        case 'S':\n          this.style = AnnotationBorderStyleType.SOLID;\n          break;\n\n        case 'D':\n          this.style = AnnotationBorderStyleType.DASHED;\n          break;\n\n        case 'B':\n          this.style = AnnotationBorderStyleType.BEVELED;\n          break;\n\n        case 'I':\n          this.style = AnnotationBorderStyleType.INSET;\n          break;\n\n        case 'U':\n          this.style = AnnotationBorderStyleType.UNDERLINE;\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Set the dash array.\n     *\n     * @public\n     * @memberof AnnotationBorderStyle\n     * @param {Array} dashArray - The dash array with at least one element\n     */\n\n  }, {\n    key: \"setDashArray\",\n    value: function setDashArray(dashArray) {\n      // We validate the dash array, but we do not use it because CSS does not\n      // allow us to change spacing of dashes. For more information, visit\n      // http://www.w3.org/TR/css3-background/#the-border-style.\n      if (Array.isArray(dashArray) && dashArray.length > 0) {\n        // According to the PDF specification: the elements in `dashArray`\n        // shall be numbers that are nonnegative and not all equal to zero.\n        var isValid = true;\n        var allZeros = true;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = dashArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var element = _step.value;\n            var validNumber = +element >= 0;\n\n            if (!validNumber) {\n              isValid = false;\n              break;\n            } else if (element > 0) {\n              allZeros = false;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (isValid && !allZeros) {\n          this.dashArray = dashArray;\n        } else {\n          this.width = 0; // Adobe behavior when the array is invalid.\n        }\n      } else if (dashArray) {\n        this.width = 0; // Adobe behavior when the array is invalid.\n      }\n    }\n    /**\n     * Set the horizontal corner radius (from a Border dictionary).\n     *\n     * @public\n     * @memberof AnnotationBorderStyle\n     * @param {number} radius - The horizontal corner radius.\n     */\n\n  }, {\n    key: \"setHorizontalCornerRadius\",\n    value: function setHorizontalCornerRadius(radius) {\n      if (Number.isInteger(radius)) {\n        this.horizontalCornerRadius = radius;\n      }\n    }\n    /**\n     * Set the vertical corner radius (from a Border dictionary).\n     *\n     * @public\n     * @memberof AnnotationBorderStyle\n     * @param {number} radius - The vertical corner radius.\n     */\n\n  }, {\n    key: \"setVerticalCornerRadius\",\n    value: function setVerticalCornerRadius(radius) {\n      if (Number.isInteger(radius)) {\n        this.verticalCornerRadius = radius;\n      }\n    }\n  }]);\n\n  return AnnotationBorderStyle;\n}();\n\nvar MarkupAnnotation =\n/*#__PURE__*/\nfunction (_Annotation) {\n  _inherits(MarkupAnnotation, _Annotation);\n\n  function MarkupAnnotation(parameters) {\n    var _this2;\n\n    _classCallCheck(this, MarkupAnnotation);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(MarkupAnnotation).call(this, parameters));\n    var dict = parameters.dict;\n\n    if (dict.has('IRT')) {\n      var rawIRT = dict.getRaw('IRT');\n      _this2.data.inReplyTo = isRef(rawIRT) ? rawIRT.toString() : null;\n      var rt = dict.get('RT');\n      _this2.data.replyType = isName(rt) ? rt.name : AnnotationReplyType.REPLY;\n    }\n\n    if (_this2.data.replyType === AnnotationReplyType.GROUP) {\n      // Subordinate annotations in a group should inherit\n      // the group attributes from the primary annotation.\n      var parent = dict.get('IRT');\n      _this2.data.title = stringToPDFString(parent.get('T') || '');\n\n      _this2.setContents(parent.get('Contents'));\n\n      _this2.data.contents = _this2.contents;\n\n      if (!parent.has('CreationDate')) {\n        _this2.data.creationDate = null;\n      } else {\n        _this2.setCreationDate(parent.get('CreationDate'));\n\n        _this2.data.creationDate = _this2.creationDate;\n      }\n\n      if (!parent.has('M')) {\n        _this2.data.modificationDate = null;\n      } else {\n        _this2.setModificationDate(parent.get('M'));\n\n        _this2.data.modificationDate = _this2.modificationDate;\n      }\n\n      _this2.data.hasPopup = parent.has('Popup');\n\n      if (!parent.has('C')) {\n        // Fall back to the default background color.\n        _this2.data.color = null;\n      } else {\n        _this2.setColor(parent.getArray('C'));\n\n        _this2.data.color = _this2.color;\n      }\n    } else {\n      _this2.data.title = stringToPDFString(dict.get('T') || '');\n\n      _this2.setCreationDate(dict.get('CreationDate'));\n\n      _this2.data.creationDate = _this2.creationDate;\n      _this2.data.hasPopup = dict.has('Popup');\n\n      if (!dict.has('C')) {\n        // Fall back to the default background color.\n        _this2.data.color = null;\n      }\n    }\n\n    return _this2;\n  }\n  /**\n   * Set the creation date.\n   *\n   * @public\n   * @memberof MarkupAnnotation\n   * @param {string} creationDate - PDF date string that indicates when the\n   *                                annotation was originally created\n   */\n\n\n  _createClass(MarkupAnnotation, [{\n    key: \"setCreationDate\",\n    value: function setCreationDate(creationDate) {\n      this.creationDate = isString(creationDate) ? creationDate : null;\n    }\n  }]);\n\n  return MarkupAnnotation;\n}(Annotation);\n\nvar WidgetAnnotation =\n/*#__PURE__*/\nfunction (_Annotation2) {\n  _inherits(WidgetAnnotation, _Annotation2);\n\n  function WidgetAnnotation(params) {\n    var _this3;\n\n    _classCallCheck(this, WidgetAnnotation);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(WidgetAnnotation).call(this, params));\n    var dict = params.dict;\n    var data = _this3.data;\n    data.annotationType = AnnotationType.WIDGET;\n    data.fieldName = _this3._constructFieldName(dict);\n    data.fieldValue = getInheritableProperty({\n      dict: dict,\n      key: 'V',\n      getArray: true\n    });\n    data.alternativeText = stringToPDFString(dict.get('TU') || '');\n    data.defaultAppearance = getInheritableProperty({\n      dict: dict,\n      key: 'DA'\n    }) || '';\n    var fieldType = getInheritableProperty({\n      dict: dict,\n      key: 'FT'\n    });\n    data.fieldType = isName(fieldType) ? fieldType.name : null;\n    _this3.fieldResources = getInheritableProperty({\n      dict: dict,\n      key: 'DR'\n    }) || Dict.empty;\n    data.fieldFlags = getInheritableProperty({\n      dict: dict,\n      key: 'Ff'\n    });\n\n    if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {\n      data.fieldFlags = 0;\n    }\n\n    data.readOnly = _this3.hasFieldFlag(AnnotationFieldFlag.READONLY); // Hide signatures because we cannot validate them, and unset the fieldValue\n    // since it's (most likely) a `Dict` which is non-serializable and will thus\n    // cause errors when sending annotations to the main-thread (issue 10347).\n\n    if (data.fieldType === 'Sig') {\n      data.fieldValue = null;\n\n      _this3.setFlags(AnnotationFlag.HIDDEN);\n    }\n\n    return _this3;\n  }\n  /**\n   * Construct the (fully qualified) field name from the (partial) field\n   * names of the field and its ancestors.\n   *\n   * @private\n   * @memberof WidgetAnnotation\n   * @param {Dict} dict - Complete widget annotation dictionary\n   * @returns {string}\n   */\n\n\n  _createClass(WidgetAnnotation, [{\n    key: \"_constructFieldName\",\n    value: function _constructFieldName(dict) {\n      // Both the `Parent` and `T` fields are optional. While at least one of\n      // them should be provided, bad PDF generators may fail to do so.\n      if (!dict.has('T') && !dict.has('Parent')) {\n        warn('Unknown field name, falling back to empty field name.');\n        return '';\n      } // If no parent exists, the partial and fully qualified names are equal.\n\n\n      if (!dict.has('Parent')) {\n        return stringToPDFString(dict.get('T'));\n      } // Form the fully qualified field name by appending the partial name to\n      // the parent's fully qualified name, separated by a period.\n\n\n      var fieldName = [];\n\n      if (dict.has('T')) {\n        fieldName.unshift(stringToPDFString(dict.get('T')));\n      }\n\n      var loopDict = dict;\n\n      while (loopDict.has('Parent')) {\n        loopDict = loopDict.get('Parent');\n\n        if (!isDict(loopDict)) {\n          // Even though it is not allowed according to the PDF specification,\n          // bad PDF generators may provide a `Parent` entry that is not a\n          // dictionary, but `null` for example (issue 8143).\n          break;\n        }\n\n        if (loopDict.has('T')) {\n          fieldName.unshift(stringToPDFString(loopDict.get('T')));\n        }\n      }\n\n      return fieldName.join('.');\n    }\n    /**\n     * Check if a provided field flag is set.\n     *\n     * @public\n     * @memberof WidgetAnnotation\n     * @param {number} flag - Hexadecimal representation for an annotation\n     *                        field characteristic\n     * @returns {boolean}\n     * @see {@link shared/util.js}\n     */\n\n  }, {\n    key: \"hasFieldFlag\",\n    value: function hasFieldFlag(flag) {\n      return !!(this.data.fieldFlags & flag);\n    }\n  }, {\n    key: \"getOperatorList\",\n    value: function getOperatorList(evaluator, task, renderForms) {\n      // Do not render form elements on the canvas when interactive forms are\n      // enabled. The display layer is responsible for rendering them instead.\n      if (renderForms) {\n        return Promise.resolve(new OperatorList());\n      }\n\n      return _get(_getPrototypeOf(WidgetAnnotation.prototype), \"getOperatorList\", this).call(this, evaluator, task, renderForms);\n    }\n  }]);\n\n  return WidgetAnnotation;\n}(Annotation);\n\nvar TextWidgetAnnotation =\n/*#__PURE__*/\nfunction (_WidgetAnnotation) {\n  _inherits(TextWidgetAnnotation, _WidgetAnnotation);\n\n  function TextWidgetAnnotation(params) {\n    var _this4;\n\n    _classCallCheck(this, TextWidgetAnnotation);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(TextWidgetAnnotation).call(this, params));\n    var dict = params.dict; // The field value is always a string.\n\n    _this4.data.fieldValue = stringToPDFString(_this4.data.fieldValue || ''); // Determine the alignment of text in the field.\n\n    var alignment = getInheritableProperty({\n      dict: dict,\n      key: 'Q'\n    });\n\n    if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {\n      alignment = null;\n    }\n\n    _this4.data.textAlignment = alignment; // Determine the maximum length of text in the field.\n\n    var maximumLength = getInheritableProperty({\n      dict: dict,\n      key: 'MaxLen'\n    });\n\n    if (!Number.isInteger(maximumLength) || maximumLength < 0) {\n      maximumLength = null;\n    }\n\n    _this4.data.maxLen = maximumLength; // Process field flags for the display layer.\n\n    _this4.data.multiLine = _this4.hasFieldFlag(AnnotationFieldFlag.MULTILINE);\n    _this4.data.comb = _this4.hasFieldFlag(AnnotationFieldFlag.COMB) && !_this4.hasFieldFlag(AnnotationFieldFlag.MULTILINE) && !_this4.hasFieldFlag(AnnotationFieldFlag.PASSWORD) && !_this4.hasFieldFlag(AnnotationFieldFlag.FILESELECT) && _this4.data.maxLen !== null;\n    return _this4;\n  }\n\n  _createClass(TextWidgetAnnotation, [{\n    key: \"getOperatorList\",\n    value: function getOperatorList(evaluator, task, renderForms) {\n      if (renderForms || this.appearance) {\n        return _get(_getPrototypeOf(TextWidgetAnnotation.prototype), \"getOperatorList\", this).call(this, evaluator, task, renderForms);\n      }\n\n      var operatorList = new OperatorList(); // Even if there is an appearance stream, ignore it. This is the\n      // behaviour used by Adobe Reader.\n\n      if (!this.data.defaultAppearance) {\n        return Promise.resolve(operatorList);\n      }\n\n      var stream = new Stream(stringToBytes(this.data.defaultAppearance));\n      return evaluator.getOperatorList({\n        stream: stream,\n        task: task,\n        resources: this.fieldResources,\n        operatorList: operatorList\n      }).then(function () {\n        return operatorList;\n      });\n    }\n  }]);\n\n  return TextWidgetAnnotation;\n}(WidgetAnnotation);\n\nvar ButtonWidgetAnnotation =\n/*#__PURE__*/\nfunction (_WidgetAnnotation2) {\n  _inherits(ButtonWidgetAnnotation, _WidgetAnnotation2);\n\n  function ButtonWidgetAnnotation(params) {\n    var _this5;\n\n    _classCallCheck(this, ButtonWidgetAnnotation);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(ButtonWidgetAnnotation).call(this, params));\n    _this5.data.checkBox = !_this5.hasFieldFlag(AnnotationFieldFlag.RADIO) && !_this5.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);\n    _this5.data.radioButton = _this5.hasFieldFlag(AnnotationFieldFlag.RADIO) && !_this5.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);\n    _this5.data.pushButton = _this5.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);\n\n    if (_this5.data.checkBox) {\n      _this5._processCheckBox(params);\n    } else if (_this5.data.radioButton) {\n      _this5._processRadioButton(params);\n    } else if (_this5.data.pushButton) {\n      _this5._processPushButton(params);\n    } else {\n      warn('Invalid field flags for button widget annotation');\n    }\n\n    return _this5;\n  }\n\n  _createClass(ButtonWidgetAnnotation, [{\n    key: \"_processCheckBox\",\n    value: function _processCheckBox(params) {\n      if (isName(this.data.fieldValue)) {\n        this.data.fieldValue = this.data.fieldValue.name;\n      }\n\n      var customAppearance = params.dict.get('AP');\n\n      if (!isDict(customAppearance)) {\n        return;\n      }\n\n      var exportValueOptionsDict = customAppearance.get('D');\n\n      if (!isDict(exportValueOptionsDict)) {\n        return;\n      }\n\n      var exportValues = exportValueOptionsDict.getKeys();\n      var hasCorrectOptionCount = exportValues.length === 2;\n\n      if (!hasCorrectOptionCount) {\n        return;\n      }\n\n      this.data.exportValue = exportValues[0] === 'Off' ? exportValues[1] : exportValues[0];\n    }\n  }, {\n    key: \"_processRadioButton\",\n    value: function _processRadioButton(params) {\n      this.data.fieldValue = this.data.buttonValue = null; // The parent field's `V` entry holds a `Name` object with the appearance\n      // state of whichever child field is currently in the \"on\" state.\n\n      var fieldParent = params.dict.get('Parent');\n\n      if (isDict(fieldParent) && fieldParent.has('V')) {\n        var fieldParentValue = fieldParent.get('V');\n\n        if (isName(fieldParentValue)) {\n          this.data.fieldValue = fieldParentValue.name;\n        }\n      } // The button's value corresponds to its appearance state.\n\n\n      var appearanceStates = params.dict.get('AP');\n\n      if (!isDict(appearanceStates)) {\n        return;\n      }\n\n      var normalAppearanceState = appearanceStates.get('N');\n\n      if (!isDict(normalAppearanceState)) {\n        return;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = normalAppearanceState.getKeys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n\n          if (key !== 'Off') {\n            this.data.buttonValue = key;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_processPushButton\",\n    value: function _processPushButton(params) {\n      if (!params.dict.has('A')) {\n        warn('Push buttons without action dictionaries are not supported');\n        return;\n      }\n\n      Catalog.parseDestDictionary({\n        destDict: params.dict,\n        resultObj: this.data,\n        docBaseUrl: params.pdfManager.docBaseUrl\n      });\n    }\n  }]);\n\n  return ButtonWidgetAnnotation;\n}(WidgetAnnotation);\n\nvar ChoiceWidgetAnnotation =\n/*#__PURE__*/\nfunction (_WidgetAnnotation3) {\n  _inherits(ChoiceWidgetAnnotation, _WidgetAnnotation3);\n\n  function ChoiceWidgetAnnotation(params) {\n    var _this6;\n\n    _classCallCheck(this, ChoiceWidgetAnnotation);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(ChoiceWidgetAnnotation).call(this, params)); // Determine the options. The options array may consist of strings or\n    // arrays. If the array consists of arrays, then the first element of\n    // each array is the export value and the second element of each array is\n    // the display value. If the array consists of strings, then these\n    // represent both the export and display value. In this case, we convert\n    // it to an array of arrays as well for convenience in the display layer.\n    // Note that the specification does not state that the `Opt` field is\n    // inheritable, but in practice PDF generators do make annotations\n    // inherit the options from a parent annotation (issue 8094).\n\n    _this6.data.options = [];\n    var options = getInheritableProperty({\n      dict: params.dict,\n      key: 'Opt'\n    });\n\n    if (Array.isArray(options)) {\n      var xref = params.xref;\n\n      for (var i = 0, ii = options.length; i < ii; i++) {\n        var option = xref.fetchIfRef(options[i]);\n        var isOptionArray = Array.isArray(option);\n        _this6.data.options[i] = {\n          exportValue: isOptionArray ? xref.fetchIfRef(option[0]) : option,\n          displayValue: stringToPDFString(isOptionArray ? xref.fetchIfRef(option[1]) : option)\n        };\n      }\n    } // Determine the field value. In this case, it may be a string or an\n    // array of strings. For convenience in the display layer, convert the\n    // string to an array of one string as well.\n\n\n    if (!Array.isArray(_this6.data.fieldValue)) {\n      _this6.data.fieldValue = [_this6.data.fieldValue];\n    } // Process field flags for the display layer.\n\n\n    _this6.data.combo = _this6.hasFieldFlag(AnnotationFieldFlag.COMBO);\n    _this6.data.multiSelect = _this6.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);\n    return _this6;\n  }\n\n  return ChoiceWidgetAnnotation;\n}(WidgetAnnotation);\n\nvar TextAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation) {\n  _inherits(TextAnnotation, _MarkupAnnotation);\n\n  function TextAnnotation(parameters) {\n    var _this7;\n\n    _classCallCheck(this, TextAnnotation);\n\n    var DEFAULT_ICON_SIZE = 22; // px\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(TextAnnotation).call(this, parameters));\n    var dict = parameters.dict;\n    _this7.data.annotationType = AnnotationType.TEXT;\n\n    if (_this7.data.hasAppearance) {\n      _this7.data.name = 'NoIcon';\n    } else {\n      _this7.data.rect[1] = _this7.data.rect[3] - DEFAULT_ICON_SIZE;\n      _this7.data.rect[2] = _this7.data.rect[0] + DEFAULT_ICON_SIZE;\n      _this7.data.name = dict.has('Name') ? dict.get('Name').name : 'Note';\n    }\n\n    if (dict.has('State')) {\n      _this7.data.state = dict.get('State') || null;\n      _this7.data.stateModel = dict.get('StateModel') || null;\n    } else {\n      _this7.data.state = null;\n      _this7.data.stateModel = null;\n    }\n\n    return _this7;\n  }\n\n  return TextAnnotation;\n}(MarkupAnnotation);\n\nvar LinkAnnotation =\n/*#__PURE__*/\nfunction (_Annotation3) {\n  _inherits(LinkAnnotation, _Annotation3);\n\n  function LinkAnnotation(params) {\n    var _this8;\n\n    _classCallCheck(this, LinkAnnotation);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(LinkAnnotation).call(this, params));\n    _this8.data.annotationType = AnnotationType.LINK;\n    var quadPoints = getQuadPoints(params.dict, _this8.rectangle);\n\n    if (quadPoints) {\n      _this8.data.quadPoints = quadPoints;\n    }\n\n    Catalog.parseDestDictionary({\n      destDict: params.dict,\n      resultObj: _this8.data,\n      docBaseUrl: params.pdfManager.docBaseUrl\n    });\n    return _this8;\n  }\n\n  return LinkAnnotation;\n}(Annotation);\n\nvar PopupAnnotation =\n/*#__PURE__*/\nfunction (_Annotation4) {\n  _inherits(PopupAnnotation, _Annotation4);\n\n  function PopupAnnotation(parameters) {\n    var _this9;\n\n    _classCallCheck(this, PopupAnnotation);\n\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(PopupAnnotation).call(this, parameters));\n    _this9.data.annotationType = AnnotationType.POPUP;\n    var parentItem = parameters.dict.get('Parent');\n\n    if (!parentItem) {\n      warn('Popup annotation has a missing or invalid parent annotation.');\n      return _possibleConstructorReturn(_this9);\n    }\n\n    var parentSubtype = parentItem.get('Subtype');\n    _this9.data.parentType = isName(parentSubtype) ? parentSubtype.name : null;\n    var rawParent = parameters.dict.getRaw('Parent');\n    _this9.data.parentId = isRef(rawParent) ? rawParent.toString() : null;\n    var rt = parentItem.get('RT');\n\n    if (isName(rt, AnnotationReplyType.GROUP)) {\n      // Subordinate annotations in a group should inherit\n      // the group attributes from the primary annotation.\n      parentItem = parentItem.get('IRT');\n    }\n\n    if (!parentItem.has('M')) {\n      _this9.data.modificationDate = null;\n    } else {\n      _this9.setModificationDate(parentItem.get('M'));\n\n      _this9.data.modificationDate = _this9.modificationDate;\n    }\n\n    if (!parentItem.has('C')) {\n      // Fall back to the default background color.\n      _this9.data.color = null;\n    } else {\n      _this9.setColor(parentItem.getArray('C'));\n\n      _this9.data.color = _this9.color;\n    } // If the Popup annotation is not viewable, but the parent annotation is,\n    // that is most likely a bug. Fallback to inherit the flags from the parent\n    // annotation (this is consistent with the behaviour in Adobe Reader).\n\n\n    if (!_this9.viewable) {\n      var parentFlags = parentItem.get('F');\n\n      if (_this9._isViewable(parentFlags)) {\n        _this9.setFlags(parentFlags);\n      }\n    }\n\n    _this9.data.title = stringToPDFString(parentItem.get('T') || '');\n    _this9.data.contents = stringToPDFString(parentItem.get('Contents') || '');\n    return _this9;\n  }\n\n  return PopupAnnotation;\n}(Annotation);\n\nvar FreeTextAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation2) {\n  _inherits(FreeTextAnnotation, _MarkupAnnotation2);\n\n  function FreeTextAnnotation(parameters) {\n    var _this10;\n\n    _classCallCheck(this, FreeTextAnnotation);\n\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(FreeTextAnnotation).call(this, parameters));\n    _this10.data.annotationType = AnnotationType.FREETEXT;\n    return _this10;\n  }\n\n  return FreeTextAnnotation;\n}(MarkupAnnotation);\n\nvar LineAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation3) {\n  _inherits(LineAnnotation, _MarkupAnnotation3);\n\n  function LineAnnotation(parameters) {\n    var _this11;\n\n    _classCallCheck(this, LineAnnotation);\n\n    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(LineAnnotation).call(this, parameters));\n    _this11.data.annotationType = AnnotationType.LINE;\n    _this11.data.lineCoordinates = Util.normalizeRect(parameters.dict.getArray('L'));\n    return _this11;\n  }\n\n  return LineAnnotation;\n}(MarkupAnnotation);\n\nvar SquareAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation4) {\n  _inherits(SquareAnnotation, _MarkupAnnotation4);\n\n  function SquareAnnotation(parameters) {\n    var _this12;\n\n    _classCallCheck(this, SquareAnnotation);\n\n    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(SquareAnnotation).call(this, parameters));\n    _this12.data.annotationType = AnnotationType.SQUARE;\n    return _this12;\n  }\n\n  return SquareAnnotation;\n}(MarkupAnnotation);\n\nvar CircleAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation5) {\n  _inherits(CircleAnnotation, _MarkupAnnotation5);\n\n  function CircleAnnotation(parameters) {\n    var _this13;\n\n    _classCallCheck(this, CircleAnnotation);\n\n    _this13 = _possibleConstructorReturn(this, _getPrototypeOf(CircleAnnotation).call(this, parameters));\n    _this13.data.annotationType = AnnotationType.CIRCLE;\n    return _this13;\n  }\n\n  return CircleAnnotation;\n}(MarkupAnnotation);\n\nvar PolylineAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation6) {\n  _inherits(PolylineAnnotation, _MarkupAnnotation6);\n\n  function PolylineAnnotation(parameters) {\n    var _this14;\n\n    _classCallCheck(this, PolylineAnnotation);\n\n    _this14 = _possibleConstructorReturn(this, _getPrototypeOf(PolylineAnnotation).call(this, parameters));\n    _this14.data.annotationType = AnnotationType.POLYLINE; // The vertices array is an array of numbers representing the alternating\n    // horizontal and vertical coordinates, respectively, of each vertex.\n    // Convert this to an array of objects with x and y coordinates.\n\n    var rawVertices = parameters.dict.getArray('Vertices');\n    _this14.data.vertices = [];\n\n    for (var i = 0, ii = rawVertices.length; i < ii; i += 2) {\n      _this14.data.vertices.push({\n        x: rawVertices[i],\n        y: rawVertices[i + 1]\n      });\n    }\n\n    return _this14;\n  }\n\n  return PolylineAnnotation;\n}(MarkupAnnotation);\n\nvar PolygonAnnotation =\n/*#__PURE__*/\nfunction (_PolylineAnnotation) {\n  _inherits(PolygonAnnotation, _PolylineAnnotation);\n\n  function PolygonAnnotation(parameters) {\n    var _this15;\n\n    _classCallCheck(this, PolygonAnnotation);\n\n    // Polygons are specific forms of polylines, so reuse their logic.\n    _this15 = _possibleConstructorReturn(this, _getPrototypeOf(PolygonAnnotation).call(this, parameters));\n    _this15.data.annotationType = AnnotationType.POLYGON;\n    return _this15;\n  }\n\n  return PolygonAnnotation;\n}(PolylineAnnotation);\n\nvar CaretAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation7) {\n  _inherits(CaretAnnotation, _MarkupAnnotation7);\n\n  function CaretAnnotation(parameters) {\n    var _this16;\n\n    _classCallCheck(this, CaretAnnotation);\n\n    _this16 = _possibleConstructorReturn(this, _getPrototypeOf(CaretAnnotation).call(this, parameters));\n    _this16.data.annotationType = AnnotationType.CARET;\n    return _this16;\n  }\n\n  return CaretAnnotation;\n}(MarkupAnnotation);\n\nvar InkAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation8) {\n  _inherits(InkAnnotation, _MarkupAnnotation8);\n\n  function InkAnnotation(parameters) {\n    var _this17;\n\n    _classCallCheck(this, InkAnnotation);\n\n    _this17 = _possibleConstructorReturn(this, _getPrototypeOf(InkAnnotation).call(this, parameters));\n    _this17.data.annotationType = AnnotationType.INK;\n    var xref = parameters.xref;\n    var originalInkLists = parameters.dict.getArray('InkList');\n    _this17.data.inkLists = [];\n\n    for (var i = 0, ii = originalInkLists.length; i < ii; ++i) {\n      // The raw ink lists array contains arrays of numbers representing\n      // the alternating horizontal and vertical coordinates, respectively,\n      // of each vertex. Convert this to an array of objects with x and y\n      // coordinates.\n      _this17.data.inkLists.push([]);\n\n      for (var j = 0, jj = originalInkLists[i].length; j < jj; j += 2) {\n        _this17.data.inkLists[i].push({\n          x: xref.fetchIfRef(originalInkLists[i][j]),\n          y: xref.fetchIfRef(originalInkLists[i][j + 1])\n        });\n      }\n    }\n\n    return _this17;\n  }\n\n  return InkAnnotation;\n}(MarkupAnnotation);\n\nvar HighlightAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation9) {\n  _inherits(HighlightAnnotation, _MarkupAnnotation9);\n\n  function HighlightAnnotation(parameters) {\n    var _this18;\n\n    _classCallCheck(this, HighlightAnnotation);\n\n    _this18 = _possibleConstructorReturn(this, _getPrototypeOf(HighlightAnnotation).call(this, parameters));\n    _this18.data.annotationType = AnnotationType.HIGHLIGHT;\n    var quadPoints = getQuadPoints(parameters.dict, _this18.rectangle);\n\n    if (quadPoints) {\n      _this18.data.quadPoints = quadPoints;\n    }\n\n    return _this18;\n  }\n\n  return HighlightAnnotation;\n}(MarkupAnnotation);\n\nvar UnderlineAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation10) {\n  _inherits(UnderlineAnnotation, _MarkupAnnotation10);\n\n  function UnderlineAnnotation(parameters) {\n    var _this19;\n\n    _classCallCheck(this, UnderlineAnnotation);\n\n    _this19 = _possibleConstructorReturn(this, _getPrototypeOf(UnderlineAnnotation).call(this, parameters));\n    _this19.data.annotationType = AnnotationType.UNDERLINE;\n    var quadPoints = getQuadPoints(parameters.dict, _this19.rectangle);\n\n    if (quadPoints) {\n      _this19.data.quadPoints = quadPoints;\n    }\n\n    return _this19;\n  }\n\n  return UnderlineAnnotation;\n}(MarkupAnnotation);\n\nvar SquigglyAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation11) {\n  _inherits(SquigglyAnnotation, _MarkupAnnotation11);\n\n  function SquigglyAnnotation(parameters) {\n    var _this20;\n\n    _classCallCheck(this, SquigglyAnnotation);\n\n    _this20 = _possibleConstructorReturn(this, _getPrototypeOf(SquigglyAnnotation).call(this, parameters));\n    _this20.data.annotationType = AnnotationType.SQUIGGLY;\n    var quadPoints = getQuadPoints(parameters.dict, _this20.rectangle);\n\n    if (quadPoints) {\n      _this20.data.quadPoints = quadPoints;\n    }\n\n    return _this20;\n  }\n\n  return SquigglyAnnotation;\n}(MarkupAnnotation);\n\nvar StrikeOutAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation12) {\n  _inherits(StrikeOutAnnotation, _MarkupAnnotation12);\n\n  function StrikeOutAnnotation(parameters) {\n    var _this21;\n\n    _classCallCheck(this, StrikeOutAnnotation);\n\n    _this21 = _possibleConstructorReturn(this, _getPrototypeOf(StrikeOutAnnotation).call(this, parameters));\n    _this21.data.annotationType = AnnotationType.STRIKEOUT;\n    var quadPoints = getQuadPoints(parameters.dict, _this21.rectangle);\n\n    if (quadPoints) {\n      _this21.data.quadPoints = quadPoints;\n    }\n\n    return _this21;\n  }\n\n  return StrikeOutAnnotation;\n}(MarkupAnnotation);\n\nvar StampAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation13) {\n  _inherits(StampAnnotation, _MarkupAnnotation13);\n\n  function StampAnnotation(parameters) {\n    var _this22;\n\n    _classCallCheck(this, StampAnnotation);\n\n    _this22 = _possibleConstructorReturn(this, _getPrototypeOf(StampAnnotation).call(this, parameters));\n    _this22.data.annotationType = AnnotationType.STAMP;\n    return _this22;\n  }\n\n  return StampAnnotation;\n}(MarkupAnnotation);\n\nvar FileAttachmentAnnotation =\n/*#__PURE__*/\nfunction (_MarkupAnnotation14) {\n  _inherits(FileAttachmentAnnotation, _MarkupAnnotation14);\n\n  function FileAttachmentAnnotation(parameters) {\n    var _this23;\n\n    _classCallCheck(this, FileAttachmentAnnotation);\n\n    _this23 = _possibleConstructorReturn(this, _getPrototypeOf(FileAttachmentAnnotation).call(this, parameters));\n    var file = new FileSpec(parameters.dict.get('FS'), parameters.xref);\n    _this23.data.annotationType = AnnotationType.FILEATTACHMENT;\n    _this23.data.file = file.serializable;\n    return _this23;\n  }\n\n  return FileAttachmentAnnotation;\n}(MarkupAnnotation);\n\nexport { Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints };",null]}