{"remainingRequest":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/thread-loader/dist/cjs.js!/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/babel-loader/lib/index.js!/Users/weizhang/JAVASHOP/mylibrary-ui/src/statics/viewer/pdf/web/pdf_history.js","dependencies":[{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/src/statics/viewer/pdf/web/pdf_history.js","mtime":1577806166000},{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/mylibrary-ui/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Copyright 2017 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getGlobalEventBus, isValidRotation, parseQueryString, waitOnEventOrTimeout } from './ui_utils'; // Heuristic value used when force-resetting `this._blockHashChange`.\n\nvar HASH_CHANGE_TIMEOUT = 1000; // milliseconds\n// Heuristic value used when adding the current position to the browser history.\n\nvar POSITION_UPDATED_THRESHOLD = 50; // Heuristic value used when adding a temporary position to the browser history.\n\nvar UPDATE_VIEWAREA_TIMEOUT = 1000; // milliseconds\n\n/**\n * @typedef {Object} PDFHistoryOptions\n * @property {IPDFLinkService} linkService - The navigation/linking service.\n * @property {EventBus} eventBus - The application event bus.\n */\n\n/**\n * @typedef {Object} InitializeParameters\n * @property {string} fingerprint - The PDF document's unique fingerprint.\n * @property {boolean} [resetHistory] - Reset the browsing history.\n * @property {boolean} [updateUrl] - Attempt to update the document URL, with\n *   the current hash, when pushing/replacing browser history entries.\n */\n\n/**\n * @typedef {Object} PushParameters\n * @property {string} [namedDest] - The named destination. If absent, a\n *   stringified version of `explicitDest` is used.\n * @property {Array} explicitDest - The explicit destination array.\n * @property {number} pageNumber - The page to which the destination points.\n */\n\nfunction getCurrentHash() {\n  return document.location.hash;\n}\n\nfunction parseCurrentHash(linkService) {\n  var hash = unescape(getCurrentHash()).substring(1);\n  var params = parseQueryString(hash);\n  var page = params.page | 0;\n\n  if (!(Number.isInteger(page) && page > 0 && page <= linkService.pagesCount)) {\n    page = null;\n  }\n\n  return {\n    hash: hash,\n    page: page,\n    rotation: linkService.rotation\n  };\n}\n\nvar PDFHistory =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {PDFHistoryOptions} options\n   */\n  function PDFHistory(_ref) {\n    var _this = this;\n\n    var linkService = _ref.linkService,\n        eventBus = _ref.eventBus;\n\n    _classCallCheck(this, PDFHistory);\n\n    this.linkService = linkService;\n    this.eventBus = eventBus || getGlobalEventBus();\n    this.initialized = false;\n    this.initialBookmark = null;\n    this.initialRotation = null;\n    this._boundEvents = Object.create(null);\n    this._isViewerInPresentationMode = false;\n    this._isPagesLoaded = false; // Ensure that we don't miss either a 'presentationmodechanged' or a\n    // 'pagesloaded' event, by registering the listeners immediately.\n\n    this.eventBus.on('presentationmodechanged', function (evt) {\n      _this._isViewerInPresentationMode = evt.active || evt.switchInProgress;\n    });\n    this.eventBus.on('pagesloaded', function (evt) {\n      _this._isPagesLoaded = !!evt.pagesCount;\n    });\n  }\n  /**\n   * Initialize the history for the PDF document, using either the current\n   * browser history entry or the document hash, whichever is present.\n   * @param {InitializeParameters} params\n   */\n\n\n  _createClass(PDFHistory, [{\n    key: \"initialize\",\n    value: function initialize(_ref2) {\n      var fingerprint = _ref2.fingerprint,\n          _ref2$resetHistory = _ref2.resetHistory,\n          resetHistory = _ref2$resetHistory === void 0 ? false : _ref2$resetHistory,\n          _ref2$updateUrl = _ref2.updateUrl,\n          updateUrl = _ref2$updateUrl === void 0 ? false : _ref2$updateUrl;\n\n      if (!fingerprint || typeof fingerprint !== 'string') {\n        console.error('PDFHistory.initialize: The \"fingerprint\" must be a non-empty string.');\n        return;\n      }\n\n      var reInitialized = this.initialized && this.fingerprint !== fingerprint;\n      this.fingerprint = fingerprint;\n      this._updateUrl = updateUrl === true;\n\n      if (!this.initialized) {\n        this._bindEvents();\n      }\n\n      var state = window.history.state;\n      this.initialized = true;\n      this.initialBookmark = null;\n      this.initialRotation = null;\n      this._popStateInProgress = false;\n      this._blockHashChange = 0;\n      this._currentHash = getCurrentHash();\n      this._numPositionUpdates = 0;\n      this._uid = this._maxUid = 0;\n      this._destination = null;\n      this._position = null;\n\n      if (!this._isValidState(state,\n      /* checkReload = */\n      true) || resetHistory) {\n        var _parseCurrentHash = parseCurrentHash(this.linkService),\n            hash = _parseCurrentHash.hash,\n            page = _parseCurrentHash.page,\n            rotation = _parseCurrentHash.rotation;\n\n        if (!hash || reInitialized || resetHistory) {\n          // Ensure that the browser history is reset on PDF document load.\n          this._pushOrReplaceState(null,\n          /* forceReplace = */\n          true);\n\n          return;\n        } // Ensure that the browser history is initialized correctly when\n        // the document hash is present on PDF document load.\n\n\n        this._pushOrReplaceState({\n          hash: hash,\n          page: page,\n          rotation: rotation\n        },\n        /* forceReplace = */\n        true);\n\n        return;\n      } // The browser history contains a valid entry, ensure that the history is\n      // initialized correctly on PDF document load.\n\n\n      var destination = state.destination;\n\n      this._updateInternalState(destination, state.uid,\n      /* removeTemporary = */\n      true);\n\n      if (this._uid > this._maxUid) {\n        this._maxUid = this._uid;\n      }\n\n      if (destination.rotation !== undefined) {\n        this.initialRotation = destination.rotation;\n      }\n\n      if (destination.dest) {\n        this.initialBookmark = JSON.stringify(destination.dest); // If the history is updated, e.g. through the user changing the hash,\n        // before the initial destination has become visible, then we do *not*\n        // want to potentially add `this._position` to the browser history.\n\n        this._destination.page = null;\n      } else if (destination.hash) {\n        this.initialBookmark = destination.hash;\n      } else if (destination.page) {\n        // Fallback case; shouldn't be necessary, but better safe than sorry.\n        this.initialBookmark = \"page=\".concat(destination.page);\n      }\n    }\n    /**\n     * Push an internal destination to the browser history.\n     * @param {PushParameters}\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(_ref3) {\n      var _this2 = this;\n\n      var _ref3$namedDest = _ref3.namedDest,\n          namedDest = _ref3$namedDest === void 0 ? null : _ref3$namedDest,\n          explicitDest = _ref3.explicitDest,\n          pageNumber = _ref3.pageNumber;\n\n      if (!this.initialized) {\n        return;\n      }\n\n      if (namedDest && typeof namedDest !== 'string') {\n        console.error('PDFHistory.push: ' + \"\\\"\".concat(namedDest, \"\\\" is not a valid namedDest parameter.\"));\n        return;\n      } else if (!Array.isArray(explicitDest)) {\n        console.error('PDFHistory.push: ' + \"\\\"\".concat(explicitDest, \"\\\" is not a valid explicitDest parameter.\"));\n        return;\n      } else if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.linkService.pagesCount)) {\n        // Allow an unset `pageNumber` if and only if the history is still empty;\n        // please refer to the `this._destination.page = null;` comment above.\n        if (pageNumber !== null || this._destination) {\n          console.error('PDFHistory.push: ' + \"\\\"\".concat(pageNumber, \"\\\" is not a valid pageNumber parameter.\"));\n          return;\n        }\n      }\n\n      var hash = namedDest || JSON.stringify(explicitDest);\n\n      if (!hash) {\n        // The hash *should* never be undefined, but if that were to occur,\n        // avoid any possible issues by not updating the browser history.\n        return;\n      }\n\n      var forceReplace = false;\n\n      if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {\n        // When the new destination is identical to `this._destination`, and\n        // its `page` is undefined, replace the current browser history entry.\n        // NOTE: This can only occur if `this._destination` was set either:\n        //  - through the document hash being specified on load.\n        //  - through the user changing the hash of the document.\n        if (this._destination.page) {\n          return;\n        }\n\n        forceReplace = true;\n      }\n\n      if (this._popStateInProgress && !forceReplace) {\n        return;\n      }\n\n      this._pushOrReplaceState({\n        dest: explicitDest,\n        hash: hash,\n        page: pageNumber,\n        rotation: this.linkService.rotation\n      }, forceReplace);\n\n      if (!this._popStateInProgress) {\n        // Prevent the browser history from updating while the new destination is\n        // being scrolled into view, to avoid potentially inconsistent state.\n        this._popStateInProgress = true; // We defer the resetting of `this._popStateInProgress`, to account for\n        // e.g. zooming occuring when the new destination is being navigated to.\n\n        Promise.resolve().then(function () {\n          _this2._popStateInProgress = false;\n        });\n      }\n    }\n    /**\n     * Push the current position to the browser history.\n     */\n\n  }, {\n    key: \"pushCurrentPosition\",\n    value: function pushCurrentPosition() {\n      if (!this.initialized || this._popStateInProgress) {\n        return;\n      }\n\n      this._tryPushCurrentPosition();\n    }\n    /**\n     * Go back one step in the browser history.\n     * NOTE: Avoids navigating away from the document, useful for \"named actions\".\n     */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      if (!this.initialized || this._popStateInProgress) {\n        return;\n      }\n\n      var state = window.history.state;\n\n      if (this._isValidState(state) && state.uid > 0) {\n        window.history.back();\n      }\n    }\n    /**\n     * Go forward one step in the browser history.\n     * NOTE: Avoids navigating away from the document, useful for \"named actions\".\n     */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      if (!this.initialized || this._popStateInProgress) {\n        return;\n      }\n\n      var state = window.history.state;\n\n      if (this._isValidState(state) && state.uid < this._maxUid) {\n        window.history.forward();\n      }\n    }\n    /**\n     * @type {boolean} Indicating if the user is currently moving through the\n     *   browser history, useful e.g. for skipping the next 'hashchange' event.\n     */\n\n  }, {\n    key: \"_pushOrReplaceState\",\n\n    /**\n     * @private\n     */\n    value: function _pushOrReplaceState(destination) {\n      var forceReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var shouldReplace = forceReplace || !this._destination;\n      var newState = {\n        fingerprint: this.fingerprint,\n        uid: shouldReplace ? this._uid : this._uid + 1,\n        destination: destination\n      };\n\n      if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('CHROME') && window.history.state && window.history.state.chromecomState) {\n        // history.state.chromecomState is managed by chromecom.js.\n        newState.chromecomState = window.history.state.chromecomState;\n      }\n\n      this._updateInternalState(destination, newState.uid);\n\n      var newUrl;\n\n      if (this._updateUrl && destination && destination.hash) {\n        var baseUrl = document.location.href.split('#')[0];\n\n        if (!baseUrl.startsWith('file://')) {\n          // Prevent errors in Firefox.\n          newUrl = \"\".concat(baseUrl, \"#\").concat(destination.hash);\n        }\n      }\n\n      if (shouldReplace) {\n        if (newUrl) {\n          window.history.replaceState(newState, '', newUrl);\n        } else {\n          window.history.replaceState(newState, '');\n        }\n      } else {\n        this._maxUid = this._uid;\n\n        if (newUrl) {\n          window.history.pushState(newState, '', newUrl);\n        } else {\n          window.history.pushState(newState, '');\n        }\n      }\n\n      if (typeof PDFJSDev !== 'undefined' && PDFJSDev.test('CHROME') && top === window) {\n        // eslint-disable-next-line no-undef\n        chrome.runtime.sendMessage('showPageAction');\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_tryPushCurrentPosition\",\n    value: function _tryPushCurrentPosition() {\n      var temporary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this._position) {\n        return;\n      }\n\n      var position = this._position;\n\n      if (temporary) {\n        position = Object.assign(Object.create(null), this._position);\n        position.temporary = true;\n      }\n\n      if (!this._destination) {\n        this._pushOrReplaceState(position);\n\n        return;\n      }\n\n      if (this._destination.temporary) {\n        // Always replace a previous *temporary* position.\n        this._pushOrReplaceState(position,\n        /* forceReplace = */\n        true);\n\n        return;\n      }\n\n      if (this._destination.hash === position.hash) {\n        return; // The current document position has not changed.\n      }\n\n      if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {\n        // `this._destination` was set through the user changing the hash of\n        // the document. Do not add `this._position` to the browser history,\n        // to avoid \"flooding\" it with lots of (nearly) identical entries,\n        // since we cannot ensure that the document position has changed.\n        return;\n      }\n\n      var forceReplace = false;\n\n      if (this._destination.page >= position.first && this._destination.page <= position.page) {\n        // When the `page` of `this._destination` is still visible, do not\n        // update the browsing history when `this._destination` either:\n        //  - contains an internal destination, since in this case we\n        //    cannot ensure that the document position has actually changed.\n        //  - was set through the user changing the hash of the document.\n        if (this._destination.dest || !this._destination.first) {\n          return;\n        } // To avoid \"flooding\" the browser history, replace the current entry.\n\n\n        forceReplace = true;\n      }\n\n      this._pushOrReplaceState(position, forceReplace);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_isValidState\",\n    value: function _isValidState(state) {\n      var checkReload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!state) {\n        return false;\n      }\n\n      if (state.fingerprint !== this.fingerprint) {\n        if (checkReload) {\n          // Potentially accept the history entry, even if the fingerprints don't\n          // match, when the viewer was reloaded (see issue 6847).\n          if (typeof state.fingerprint !== 'string' || state.fingerprint.length !== this.fingerprint.length) {\n            return false;\n          }\n\n          var _performance$getEntri = performance.getEntriesByType('navigation'),\n              _performance$getEntri2 = _slicedToArray(_performance$getEntri, 1),\n              perfEntry = _performance$getEntri2[0];\n\n          if (!perfEntry || perfEntry.type !== 'reload') {\n            return false;\n          }\n        } else {\n          // This should only occur in viewers with support for opening more than\n          // one PDF document, e.g. the GENERIC viewer.\n          return false;\n        }\n      }\n\n      if (!Number.isInteger(state.uid) || state.uid < 0) {\n        return false;\n      }\n\n      if (state.destination === null || _typeof(state.destination) !== 'object') {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_updateInternalState\",\n    value: function _updateInternalState(destination, uid) {\n      var removeTemporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (this._updateViewareaTimeout) {\n        // When updating `this._destination`, make sure that we always wait for\n        // the next 'updateviewarea' event before (potentially) attempting to\n        // push the current position to the browser history.\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n\n      if (removeTemporary && destination && destination.temporary) {\n        // When the `destination` comes from the browser history,\n        // we no longer treat it as a *temporary* position.\n        delete destination.temporary;\n      }\n\n      this._destination = destination;\n      this._uid = uid; // This should always be reset when `this._destination` is updated.\n\n      this._numPositionUpdates = 0;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_updateViewarea\",\n    value: function _updateViewarea(_ref4) {\n      var _this3 = this;\n\n      var location = _ref4.location;\n\n      if (this._updateViewareaTimeout) {\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n\n      this._position = {\n        hash: this._isViewerInPresentationMode ? \"page=\".concat(location.pageNumber) : location.pdfOpenParams.substring(1),\n        page: this.linkService.page,\n        first: location.pageNumber,\n        rotation: location.rotation\n      };\n\n      if (this._popStateInProgress) {\n        return;\n      }\n\n      if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {\n        // If the current destination was set through the user changing the hash\n        // of the document, we will usually not try to push the current position\n        // to the browser history; see `this._tryPushCurrentPosition()`.\n        //\n        // To prevent `this._tryPushCurrentPosition()` from effectively being\n        // reduced to a no-op in this case, we will assume that the position\n        // *did* in fact change if the 'updateviewarea' event was dispatched\n        // more than `POSITION_UPDATED_THRESHOLD` times.\n        this._numPositionUpdates++;\n      }\n\n      if (UPDATE_VIEWAREA_TIMEOUT > 0) {\n        // When closing the browser, a 'pagehide' event will be dispatched which\n        // *should* allow us to push the current position to the browser history.\n        // In practice, it seems that the event is arriving too late in order for\n        // the session history to be successfully updated.\n        // (For additional details, please refer to the discussion in\n        //  https://bugzilla.mozilla.org/show_bug.cgi?id=1153393.)\n        //\n        // To workaround this we attempt to *temporarily* add the current position\n        // to the browser history only when the viewer is *idle*,\n        // i.e. when scrolling and/or zooming does not occur.\n        //\n        // PLEASE NOTE: It's absolutely imperative that the browser history is\n        // *not* updated too often, since that would render the viewer more or\n        // less unusable. Hence the use of a timeout to delay the update until\n        // the viewer has been idle for `UPDATE_VIEWAREA_TIMEOUT` milliseconds.\n        this._updateViewareaTimeout = setTimeout(function () {\n          if (!_this3._popStateInProgress) {\n            _this3._tryPushCurrentPosition(\n            /* temporary = */\n            true);\n          }\n\n          _this3._updateViewareaTimeout = null;\n        }, UPDATE_VIEWAREA_TIMEOUT);\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_popState\",\n    value: function _popState(_ref5) {\n      var _this4 = this;\n\n      var state = _ref5.state;\n      var newHash = getCurrentHash(),\n          hashChanged = this._currentHash !== newHash;\n      this._currentHash = newHash;\n\n      if (!state || typeof PDFJSDev !== 'undefined' && PDFJSDev.test('CHROME') && state.chromecomState && !this._isValidState(state)) {\n        // This case corresponds to the user changing the hash of the document.\n        this._uid++;\n\n        var _parseCurrentHash2 = parseCurrentHash(this.linkService),\n            hash = _parseCurrentHash2.hash,\n            page = _parseCurrentHash2.page,\n            rotation = _parseCurrentHash2.rotation;\n\n        this._pushOrReplaceState({\n          hash: hash,\n          page: page,\n          rotation: rotation\n        },\n        /* forceReplace = */\n        true);\n\n        return;\n      }\n\n      if (!this._isValidState(state)) {\n        // This should only occur in viewers with support for opening more than\n        // one PDF document, e.g. the GENERIC viewer.\n        return;\n      } // Prevent the browser history from updating until the new destination,\n      // as stored in the browser history, has been scrolled into view.\n\n\n      this._popStateInProgress = true;\n\n      if (hashChanged) {\n        // When the hash changed, implying that the 'popstate' event will be\n        // followed by a 'hashchange' event, then we do *not* want to update the\n        // browser history when handling the 'hashchange' event (in web/app.js)\n        // since that would *overwrite* the new destination navigated to below.\n        //\n        // To avoid accidentally disabling all future user-initiated hash changes,\n        // if there's e.g. another 'hashchange' listener that stops the event\n        // propagation, we make sure to always force-reset `this._blockHashChange`\n        // after `HASH_CHANGE_TIMEOUT` milliseconds have passed.\n        this._blockHashChange++;\n        waitOnEventOrTimeout({\n          target: window,\n          name: 'hashchange',\n          delay: HASH_CHANGE_TIMEOUT\n        }).then(function () {\n          _this4._blockHashChange--;\n        });\n      } // Navigate to the new destination.\n\n\n      var destination = state.destination;\n\n      this._updateInternalState(destination, state.uid,\n      /* removeTemporary = */\n      true);\n\n      if (this._uid > this._maxUid) {\n        this._maxUid = this._uid;\n      }\n\n      if (isValidRotation(destination.rotation)) {\n        this.linkService.rotation = destination.rotation;\n      }\n\n      if (destination.dest) {\n        this.linkService.navigateTo(destination.dest);\n      } else if (destination.hash) {\n        this.linkService.setHash(destination.hash);\n      } else if (destination.page) {\n        // Fallback case; shouldn't be necessary, but better safe than sorry.\n        this.linkService.page = destination.page;\n      } // Since `PDFLinkService.navigateTo` is asynchronous, we thus defer the\n      // resetting of `this._popStateInProgress` slightly.\n\n\n      Promise.resolve().then(function () {\n        _this4._popStateInProgress = false;\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_bindEvents\",\n    value: function _bindEvents() {\n      var _this5 = this;\n\n      var _boundEvents = this._boundEvents,\n          eventBus = this.eventBus;\n      _boundEvents.updateViewarea = this._updateViewarea.bind(this);\n      _boundEvents.popState = this._popState.bind(this);\n\n      _boundEvents.pageHide = function (evt) {\n        // Attempt to push the `this._position` into the browser history when\n        // navigating away from the document. This is *only* done if the history\n        // is empty/temporary, since otherwise an existing browser history entry\n        // will end up being overwritten (given that new entries cannot be pushed\n        // into the browser history when the 'unload' event has already fired).\n        if (!_this5._destination || _this5._destination.temporary) {\n          _this5._tryPushCurrentPosition();\n        }\n      };\n\n      eventBus.on('updateviewarea', _boundEvents.updateViewarea);\n      window.addEventListener('popstate', _boundEvents.popState);\n      window.addEventListener('pagehide', _boundEvents.pageHide);\n    }\n  }, {\n    key: \"popStateInProgress\",\n    get: function get() {\n      return this.initialized && (this._popStateInProgress || this._blockHashChange > 0);\n    }\n  }]);\n\n  return PDFHistory;\n}();\n\nfunction isDestHashesEqual(destHash, pushHash) {\n  if (typeof destHash !== 'string' || typeof pushHash !== 'string') {\n    return false;\n  }\n\n  if (destHash === pushHash) {\n    return true;\n  }\n\n  var _parseQueryString = parseQueryString(destHash),\n      nameddest = _parseQueryString.nameddest;\n\n  if (nameddest === pushHash) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isDestArraysEqual(firstDest, secondDest) {\n  function isEntryEqual(first, second) {\n    if (_typeof(first) !== _typeof(second)) {\n      return false;\n    }\n\n    if (Array.isArray(first) || Array.isArray(second)) {\n      return false;\n    }\n\n    if (first !== null && _typeof(first) === 'object' && second !== null) {\n      if (Object.keys(first).length !== Object.keys(second).length) {\n        return false;\n      }\n\n      for (var key in first) {\n        if (!isEntryEqual(first[key], second[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return first === second || Number.isNaN(first) && Number.isNaN(second);\n  }\n\n  if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {\n    return false;\n  }\n\n  if (firstDest.length !== secondDest.length) {\n    return false;\n  }\n\n  for (var i = 0, ii = firstDest.length; i < ii; i++) {\n    if (!isEntryEqual(firstDest[i], secondDest[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { PDFHistory, isDestHashesEqual, isDestArraysEqual };",null]}