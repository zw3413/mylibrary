{"remainingRequest":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/babel-loader/lib/index.js!/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/eslint-loader/index.js??ref--13-0!/Users/weizhang/JAVASHOP/vue-admin-template-master/src/statics/viewer/pdf/src/core/bidi.js","dependencies":[{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/src/statics/viewer/pdf/src/core/bidi.js","mtime":1572199794000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bidi = bidi;\n\nvar _util = require(\"../shared/util\");\n\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Character types for symbols from 0000 to 00FF.\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\nvar baseTypes = ['BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'S', 'B', 'S', 'WS', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'B', 'B', 'S', 'WS', 'ON', 'ON', 'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'ON', 'ES', 'CS', 'ES', 'CS', 'CS', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'CS', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'CS', 'ON', 'ET', 'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'L', 'ON', 'ON', 'BN', 'ON', 'ON', 'ET', 'ET', 'EN', 'EN', 'ON', 'L', 'ON', 'ON', 'ON', 'EN', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L']; // Character types for symbols from 0600 to 06FF.\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n// Note that 061D does not exist in the Unicode standard (see\n// http://unicode.org/charts/PDF/U0600.pdf), so we replace it with an\n// empty string and issue a warning if we encounter this character. The\n// empty string is required to properly index the items after it.\n\nvar arabicTypes = ['AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ON', 'ON', 'AL', 'ET', 'ET', 'AL', 'CS', 'AL', 'ON', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', '', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ET', 'AN', 'AN', 'AL', 'AL', 'AL', 'NSM', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'NSM', 'NSM', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL'];\n\nfunction isOdd(i) {\n  return (i & 1) !== 0;\n}\n\nfunction isEven(i) {\n  return (i & 1) === 0;\n}\n\nfunction findUnequal(arr, start, value) {\n  for (var j = start, jj = arr.length; j < jj; ++j) {\n    if (arr[j] !== value) {\n      return j;\n    }\n  }\n\n  return j;\n}\n\nfunction setValues(arr, start, end, value) {\n  for (var j = start; j < end; ++j) {\n    arr[j] = value;\n  }\n}\n\nfunction reverseValues(arr, start, end) {\n  for (var i = start, j = end - 1; i < j; ++i, --j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n}\n\nfunction createBidiText(str, isLTR, vertical) {\n  return {\n    str: str,\n    dir: vertical ? 'ttb' : isLTR ? 'ltr' : 'rtl'\n  };\n} // These are used in bidi(), which is called frequently. We re-use them on\n// each call to avoid unnecessary allocations.\n\n\nvar chars = [];\nvar types = [];\n\nfunction bidi(str, startLevel, vertical) {\n  var isLTR = true;\n  var strLength = str.length;\n\n  if (strLength === 0 || vertical) {\n    return createBidiText(str, isLTR, vertical);\n  } // Get types and fill arrays\n\n\n  chars.length = strLength;\n  types.length = strLength;\n  var numBidi = 0;\n  var i, ii;\n\n  for (i = 0; i < strLength; ++i) {\n    chars[i] = str.charAt(i);\n    var charCode = str.charCodeAt(i);\n    var charType = 'L';\n\n    if (charCode <= 0x00ff) {\n      charType = baseTypes[charCode];\n    } else if (0x0590 <= charCode && charCode <= 0x05f4) {\n      charType = 'R';\n    } else if (0x0600 <= charCode && charCode <= 0x06ff) {\n      charType = arabicTypes[charCode & 0xff];\n\n      if (!charType) {\n        (0, _util.warn)('Bidi: invalid Unicode character ' + charCode.toString(16));\n      }\n    } else if (0x0700 <= charCode && charCode <= 0x08AC) {\n      charType = 'AL';\n    }\n\n    if (charType === 'R' || charType === 'AL' || charType === 'AN') {\n      numBidi++;\n    }\n\n    types[i] = charType;\n  } // Detect the bidi method\n  // - If there are no rtl characters then no bidi needed\n  // - If less than 30% chars are rtl then string is primarily ltr\n  // - If more than 30% chars are rtl then string is primarily rtl\n\n\n  if (numBidi === 0) {\n    isLTR = true;\n    return createBidiText(str, isLTR);\n  }\n\n  if (startLevel === -1) {\n    if (numBidi / strLength < 0.3) {\n      isLTR = true;\n      startLevel = 0;\n    } else {\n      isLTR = false;\n      startLevel = 1;\n    }\n  }\n\n  var levels = [];\n\n  for (i = 0; i < strLength; ++i) {\n    levels[i] = startLevel;\n  }\n  /*\n   X1-X10: skip most of this, since we are NOT doing the embeddings.\n   */\n\n\n  var e = isOdd(startLevel) ? 'R' : 'L';\n  var sor = e;\n  var eor = sor;\n  /*\n   W1. Examine each non-spacing mark (NSM) in the level run, and change the\n   type of the NSM to the type of the previous character. If the NSM is at the\n   start of the level run, it will get the type of sor.\n   */\n\n  var lastType = sor;\n\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'NSM') {\n      types[i] = lastType;\n    } else {\n      lastType = types[i];\n    }\n  }\n  /*\n   W2. Search backwards from each instance of a European number until the\n   first strong type (R, L, AL, or sor) is found.  If an AL is found, change\n   the type of the European number to Arabic number.\n   */\n\n\n  lastType = sor;\n  var t;\n\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n\n    if (t === 'EN') {\n      types[i] = lastType === 'AL' ? 'AN' : 'EN';\n    } else if (t === 'R' || t === 'L' || t === 'AL') {\n      lastType = t;\n    }\n  }\n  /*\n   W3. Change all ALs to R.\n   */\n\n\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n\n    if (t === 'AL') {\n      types[i] = 'R';\n    }\n  }\n  /*\n   W4. A single European separator between two European numbers changes to a\n   European number. A single common separator between two numbers of the same\n   type changes to that type:\n   */\n\n\n  for (i = 1; i < strLength - 1; ++i) {\n    if (types[i] === 'ES' && types[i - 1] === 'EN' && types[i + 1] === 'EN') {\n      types[i] = 'EN';\n    }\n\n    if (types[i] === 'CS' && (types[i - 1] === 'EN' || types[i - 1] === 'AN') && types[i + 1] === types[i - 1]) {\n      types[i] = types[i - 1];\n    }\n  }\n  /*\n   W5. A sequence of European terminators adjacent to European numbers changes\n   to all European numbers:\n   */\n\n\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'EN') {\n      // do before\n      var j;\n\n      for (j = i - 1; j >= 0; --j) {\n        if (types[j] !== 'ET') {\n          break;\n        }\n\n        types[j] = 'EN';\n      } // do after\n\n\n      for (j = i + 1; j < strLength; ++j) {\n        if (types[j] !== 'ET') {\n          break;\n        }\n\n        types[j] = 'EN';\n      }\n    }\n  }\n  /*\n   W6. Otherwise, separators and terminators change to Other Neutral:\n   */\n\n\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n\n    if (t === 'WS' || t === 'ES' || t === 'ET' || t === 'CS') {\n      types[i] = 'ON';\n    }\n  }\n  /*\n   W7. Search backwards from each instance of a European number until the\n   first strong type (R, L, or sor) is found. If an L is found,  then change\n   the type of the European number to L.\n   */\n\n\n  lastType = sor;\n\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n\n    if (t === 'EN') {\n      types[i] = lastType === 'L' ? 'L' : 'EN';\n    } else if (t === 'R' || t === 'L') {\n      lastType = t;\n    }\n  }\n  /*\n   N1. A sequence of neutrals takes the direction of the surrounding strong\n   text if the text on both sides has the same direction. European and Arabic\n   numbers are treated as though they were R. Start-of-level-run (sor) and\n   end-of-level-run (eor) are used at level run boundaries.\n   */\n\n\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'ON') {\n      var end = findUnequal(types, i + 1, 'ON');\n      var before = sor;\n\n      if (i > 0) {\n        before = types[i - 1];\n      }\n\n      var after = eor;\n\n      if (end + 1 < strLength) {\n        after = types[end + 1];\n      }\n\n      if (before !== 'L') {\n        before = 'R';\n      }\n\n      if (after !== 'L') {\n        after = 'R';\n      }\n\n      if (before === after) {\n        setValues(types, i, end, before);\n      }\n\n      i = end - 1; // reset to end (-1 so next iteration is ok)\n    }\n  }\n  /*\n   N2. Any remaining neutrals take the embedding direction.\n   */\n\n\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'ON') {\n      types[i] = e;\n    }\n  }\n  /*\n   I1. For all characters with an even (left-to-right) embedding direction,\n   those of type R go up one level and those of type AN or EN go up two\n   levels.\n   I2. For all characters with an odd (right-to-left) embedding direction,\n   those of type L, EN or AN go up one level.\n   */\n\n\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n\n    if (isEven(levels[i])) {\n      if (t === 'R') {\n        levels[i] += 1;\n      } else if (t === 'AN' || t === 'EN') {\n        levels[i] += 2;\n      }\n    } else {\n      // isOdd\n      if (t === 'L' || t === 'AN' || t === 'EN') {\n        levels[i] += 1;\n      }\n    }\n  }\n  /*\n   L1. On each line, reset the embedding level of the following characters to\n   the paragraph embedding level:\n    segment separators,\n   paragraph separators,\n   any sequence of whitespace characters preceding a segment separator or\n   paragraph separator, and any sequence of white space characters at the end\n   of the line.\n   */\n  // don't bother as text is only single line\n\n  /*\n   L2. From the highest level found in the text to the lowest odd level on\n   each line, reverse any contiguous sequence of characters that are at that\n   level or higher.\n   */\n  // find highest level & lowest odd level\n\n\n  var highestLevel = -1;\n  var lowestOddLevel = 99;\n  var level;\n\n  for (i = 0, ii = levels.length; i < ii; ++i) {\n    level = levels[i];\n\n    if (highestLevel < level) {\n      highestLevel = level;\n    }\n\n    if (lowestOddLevel > level && isOdd(level)) {\n      lowestOddLevel = level;\n    }\n  } // now reverse between those limits\n\n\n  for (level = highestLevel; level >= lowestOddLevel; --level) {\n    // find segments to reverse\n    var start = -1;\n\n    for (i = 0, ii = levels.length; i < ii; ++i) {\n      if (levels[i] < level) {\n        if (start >= 0) {\n          reverseValues(chars, start, i);\n          start = -1;\n        }\n      } else if (start < 0) {\n        start = i;\n      }\n    }\n\n    if (start >= 0) {\n      reverseValues(chars, start, levels.length);\n    }\n  }\n  /*\n   L3. Combining marks applied to a right-to-left base character will at this\n   point precede their base character. If the rendering engine expects them to\n   follow the base characters in the final display process, then the ordering\n   of the marks and the base character must be reversed.\n   */\n  // don't bother for now\n\n  /*\n   L4. A character that possesses the mirrored property as specified by\n   Section 4.7, Mirrored, must be depicted by a mirrored glyph if the resolved\n   directionality of that character is R.\n   */\n  // don't mirror as characters are already mirrored in the pdf\n  // Finally, return string\n\n\n  for (i = 0, ii = chars.length; i < ii; ++i) {\n    var ch = chars[i];\n\n    if (ch === '<' || ch === '>') {\n      chars[i] = '';\n    }\n  }\n\n  return createBidiText(chars.join(''), isLTR);\n}",null]}