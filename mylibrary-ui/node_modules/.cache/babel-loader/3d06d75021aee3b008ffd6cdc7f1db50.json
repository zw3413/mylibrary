{"remainingRequest":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/babel-loader/lib/index.js!/Users/weizhang/JAVASHOP/vue-admin-template-master/src/statics/viewer/pdf/web/chromecom.js","dependencies":[{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/src/statics/viewer/pdf/web/chromecom.js","mtime":1577806166000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChromeCom = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"/Users/weizhang/JAVASHOP/vue-admin-template-master/node_modules/@babel/runtime/regenerator\"));\n\nvar _app = require(\"./app\");\n\nvar _app_options = require(\"./app_options\");\n\nvar _preferences = require(\"./preferences\");\n\nvar _download_manager = require(\"./download_manager\");\n\nvar _genericl10n = require(\"./genericl10n\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nif (typeof PDFJSDev === 'undefined' || !PDFJSDev.test('CHROME')) {\n  throw new Error('Module \"pdfjs-web/chromecom\" shall not be used outside ' + 'CHROME build.');\n}\n\nvar ChromeCom = {\n  /**\n   * Creates an event that the extension is listening for and will\n   * asynchronously respond by calling the callback.\n   *\n   * @param {string} action - The action to trigger.\n   * @param {string} [data] - The data to send.\n   * @param {Function} [callback] - Response callback that will be called with\n   *   one data argument. When the request cannot be handled, the callback is\n   *   immediately invoked with no arguments.\n   */\n  request: function request(action, data, callback) {\n    var message = {\n      action: action,\n      data: data\n    };\n\n    if (!chrome.runtime) {\n      console.error('chrome.runtime is undefined.');\n\n      if (callback) {\n        callback();\n      }\n    } else if (callback) {\n      chrome.runtime.sendMessage(message, callback);\n    } else {\n      chrome.runtime.sendMessage(message);\n    }\n  },\n\n  /**\n   * Resolves a PDF file path and attempts to detects length.\n   *\n   * @param {string} file - Absolute URL of PDF file.\n   * @param {OverlayManager} overlayManager - Manager for the viewer overlays.\n   * @param {Function} callback - A callback with resolved URL and file length.\n   */\n  resolvePDFFile: function resolvePDFFile(file, overlayManager, callback) {\n    // Expand drive:-URLs to filesystem URLs (Chrome OS)\n    file = file.replace(/^drive:/i, 'filesystem:' + location.origin + '/external/');\n\n    if (/^https?:/.test(file)) {\n      // Assumption: The file being opened is the file that was requested.\n      // There is no UI to input a different URL, so this assumption will hold\n      // for now.\n      setReferer(file, function () {\n        callback(file);\n      });\n      return;\n    }\n\n    if (/^file?:/.test(file)) {\n      getEmbedderOrigin(function (origin) {\n        // If the origin cannot be determined, let Chrome decide whether to\n        // allow embedding files. Otherwise, only allow local files to be\n        // embedded from local files or Chrome extensions.\n        // Even without this check, the file load in frames is still blocked,\n        // but this may change in the future (https://crbug.com/550151).\n        if (origin && !/^file:|^chrome-extension:/.test(origin)) {\n          _app.PDFViewerApplication.error('Blocked ' + origin + ' from loading ' + file + '. Refused to load a local file in a non-local page ' + 'for security reasons.');\n\n          return;\n        }\n\n        isAllowedFileSchemeAccess(function (isAllowedAccess) {\n          if (isAllowedAccess) {\n            callback(file);\n          } else {\n            requestAccessToLocalFile(file, overlayManager, callback);\n          }\n        });\n      });\n      return;\n    }\n\n    callback(file);\n  }\n};\nexports.ChromeCom = ChromeCom;\n\nfunction getEmbedderOrigin(callback) {\n  var origin = window === top ? location.origin : location.ancestorOrigins[0];\n\n  if (origin === 'null') {\n    // file:-URLs, data-URLs, sandboxed frames, etc.\n    getParentOrigin(callback);\n  } else {\n    callback(origin);\n  }\n}\n\nfunction getParentOrigin(callback) {\n  ChromeCom.request('getParentOrigin', null, callback);\n}\n\nfunction isAllowedFileSchemeAccess(callback) {\n  ChromeCom.request('isAllowedFileSchemeAccess', null, callback);\n}\n\nfunction isRuntimeAvailable() {\n  try {\n    // When the extension is reloaded, the extension runtime is destroyed and\n    // the extension APIs become unavailable.\n    if (chrome.runtime && chrome.runtime.getManifest()) {\n      return true;\n    }\n  } catch (e) {}\n\n  return false;\n}\n\nfunction reloadIfRuntimeIsUnavailable() {\n  if (!isRuntimeAvailable()) {\n    location.reload();\n  }\n}\n\nvar chromeFileAccessOverlayPromise;\n\nfunction requestAccessToLocalFile(fileUrl, overlayManager, callback) {\n  var onCloseOverlay = null;\n\n  if (top !== window) {\n    // When the extension reloads after receiving new permissions, the pages\n    // have to be reloaded to restore the extension runtime. Auto-reload\n    // frames, because users should not have to reload the whole page just to\n    // update the viewer.\n    // Top-level frames are closed by Chrome upon reload, so there is no need\n    // for detecting unload of the top-level frame. Should this ever change\n    // (crbug.com/511670), then the user can just reload the tab.\n    window.addEventListener('focus', reloadIfRuntimeIsUnavailable);\n\n    onCloseOverlay = function onCloseOverlay() {\n      window.removeEventListener('focus', reloadIfRuntimeIsUnavailable);\n      reloadIfRuntimeIsUnavailable();\n      overlayManager.close('chromeFileAccessOverlay');\n    };\n  }\n\n  if (!chromeFileAccessOverlayPromise) {\n    chromeFileAccessOverlayPromise = overlayManager.register('chromeFileAccessOverlay', document.getElementById('chromeFileAccessOverlay'), onCloseOverlay, true);\n  }\n\n  chromeFileAccessOverlayPromise.then(function () {\n    var iconPath = chrome.runtime.getManifest().icons[48];\n    document.getElementById('chrome-pdfjs-logo-bg').style.backgroundImage = 'url(' + chrome.runtime.getURL(iconPath) + ')'; // Use Chrome's definition of UI language instead of PDF.js's #lang=...,\n    // because the shown string should match the UI at chrome://extensions.\n    // These strings are from chrome/app/resources/generated_resources_*.xtb.\n\n    /* eslint-disable no-unexpected-multiline */\n\n    var i18nFileAccessLabel = PDFJSDev.json('$ROOT/web/chrome-i18n-allow-access-to-file-urls.json')[chrome.i18n.getUILanguage && chrome.i18n.getUILanguage()];\n    /* eslint-enable no-unexpected-multiline */\n\n    if (i18nFileAccessLabel) {\n      document.getElementById('chrome-file-access-label').textContent = i18nFileAccessLabel;\n    }\n\n    var link = document.getElementById('chrome-link-to-extensions-page');\n    link.href = 'chrome://extensions/?id=' + chrome.runtime.id;\n\n    link.onclick = function (e) {\n      // Direct navigation to chrome:// URLs is blocked by Chrome, so we\n      // have to ask the background page to open chrome://extensions/?id=...\n      e.preventDefault(); // Open in the current tab by default, because toggling the file access\n      // checkbox causes the extension to reload, and Chrome will close all\n      // tabs upon reload.\n\n      ChromeCom.request('openExtensionsPageForFileAccess', {\n        newTab: e.ctrlKey || e.metaKey || e.button === 1 || window !== top\n      });\n    }; // Show which file is being opened to help the user with understanding\n    // why this permission request is shown.\n\n\n    document.getElementById('chrome-url-of-local-file').textContent = fileUrl;\n\n    document.getElementById('chrome-file-fallback').onchange = function () {\n      var file = this.files[0];\n\n      if (file) {\n        var originalFilename = decodeURIComponent(fileUrl.split('/').pop());\n        var originalUrl = fileUrl;\n\n        if (originalFilename !== file.name) {\n          var msg = 'The selected file does not match the original file.' + '\\nOriginal: ' + originalFilename + '\\nSelected: ' + file.name + '\\nDo you want to open the selected file?';\n\n          if (!confirm(msg)) {\n            this.value = '';\n            return;\n          } // There is no way to retrieve the original URL from the File object.\n          // So just generate a fake path.\n\n\n          originalUrl = 'file:///fakepath/to/' + encodeURIComponent(file.name);\n        }\n\n        callback(URL.createObjectURL(file), file.size, originalUrl);\n        overlayManager.close('chromeFileAccessOverlay');\n      }\n    };\n\n    overlayManager.open('chromeFileAccessOverlay');\n  });\n}\n\nif (window === top) {\n  // Chrome closes all extension tabs (crbug.com/511670) when the extension\n  // reloads. To counter this, the tab URL and history state is saved to\n  // localStorage and restored by extension-router.js.\n  // Unfortunately, the window and tab index are not restored. And if it was\n  // the only tab in an incognito window, then the tab is not restored either.\n  addEventListener('unload', function () {\n    // If the runtime is still available, the unload is most likely a normal\n    // tab closure. Otherwise it is most likely an extension reload.\n    if (!isRuntimeAvailable()) {\n      localStorage.setItem('unload-' + Date.now() + '-' + document.hidden + '-' + location.href, JSON.stringify(history.state));\n    }\n  });\n} // This port is used for several purposes:\n// 1. When disconnected, the background page knows that the frame has unload.\n// 2. When the referrer was saved in history.state.chromecomState, it is sent\n//    to the background page.\n// 3. When the background page knows the referrer of the page, the referrer is\n//    saved in history.state.chromecomState.\n\n\nvar port; // Set the referer for the given URL.\n// 0. Background: If loaded via a http(s) URL: Save referer.\n// 1. Page -> background: send URL and referer from history.state\n// 2. Background: Bind referer to URL (via webRequest).\n// 3. Background -> page: Send latest referer and save to history.\n// 4. Page: Invoke callback.\n\nfunction setReferer(url, callback) {\n  if (!port) {\n    // The background page will accept the port, and keep adding the Referer\n    // request header to requests to |url| until the port is disconnected.\n    port = chrome.runtime.connect({\n      name: 'chromecom-referrer'\n    });\n  }\n\n  port.onDisconnect.addListener(onDisconnect);\n  port.onMessage.addListener(onMessage); // Initiate the information exchange.\n\n  port.postMessage({\n    referer: window.history.state && window.history.state.chromecomState,\n    requestUrl: url\n  });\n\n  function onMessage(referer) {\n    if (referer) {\n      // The background extracts the Referer from the initial HTTP request for\n      // the PDF file. When the viewer is reloaded or when the user navigates\n      // back and forward, the background page will not observe a HTTP request\n      // with Referer. To make sure that the Referer is preserved, store it in\n      // history.state, which is preserved across reloads/navigations.\n      var state = window.history.state || {};\n      state.chromecomState = referer;\n      window.history.replaceState(state, '');\n    }\n\n    onCompleted();\n  }\n\n  function onDisconnect() {\n    // When the connection fails, ignore the error and call the callback.\n    port = null;\n    callback();\n  }\n\n  function onCompleted() {\n    port.onDisconnect.removeListener(onDisconnect);\n    port.onMessage.removeListener(onMessage);\n    callback();\n  }\n} // chrome.storage.sync is not supported in every Chromium-derivate.\n// Note: The background page takes care of migrating values from\n// chrome.storage.local to chrome.storage.sync when needed.\n\n\nvar storageArea = chrome.storage.sync || chrome.storage.local;\n\nvar ChromePreferences =\n/*#__PURE__*/\nfunction (_BasePreferences) {\n  _inherits(ChromePreferences, _BasePreferences);\n\n  function ChromePreferences() {\n    _classCallCheck(this, ChromePreferences);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ChromePreferences).apply(this, arguments));\n  }\n\n  _createClass(ChromePreferences, [{\n    key: \"_writeToStorage\",\n    value: function () {\n      var _writeToStorage2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(prefObj) {\n        var _this = this;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve) {\n                  if (prefObj === _this.defaults) {\n                    var keysToRemove = Object.keys(_this.defaults); // If the storage is reset, remove the keys so that the values from\n                    // managed storage are applied again.\n\n                    storageArea.remove(keysToRemove, function () {\n                      resolve();\n                    });\n                  } else {\n                    storageArea.set(prefObj, function () {\n                      resolve();\n                    });\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function _writeToStorage(_x) {\n        return _writeToStorage2.apply(this, arguments);\n      }\n\n      return _writeToStorage;\n    }()\n  }, {\n    key: \"_readFromStorage\",\n    value: function () {\n      var _readFromStorage2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2(prefObj) {\n        var _this2 = this;\n\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                  var getPreferences = function getPreferences(defaultPrefs) {\n                    if (chrome.runtime.lastError) {\n                      // Managed storage not supported, e.g. in Opera.\n                      defaultPrefs = _this2.defaults;\n                    }\n\n                    storageArea.get(defaultPrefs, function (readPrefs) {\n                      resolve(readPrefs);\n                    });\n                  };\n\n                  if (chrome.storage.managed) {\n                    // Get preferences as set by the system administrator.\n                    // See extensions/chromium/preferences_schema.json for more information.\n                    // These preferences can be overridden by the user.\n                    // Deprecated preferences are removed from web/default_preferences.json,\n                    // but kept in extensions/chromium/preferences_schema.json for backwards\n                    // compatibility with managed preferences.\n                    var defaultManagedPrefs = Object.assign({\n                      enableHandToolOnLoad: false,\n                      disableTextLayer: false,\n                      enhanceTextSelection: false,\n                      showPreviousViewOnLoad: true,\n                      disablePageMode: false\n                    }, _this2.defaults);\n                    chrome.storage.managed.get(defaultManagedPrefs, function (items) {\n                      items = items || defaultManagedPrefs; // Migration logic for deprecated preferences: If the new preference\n                      // is not defined by an administrator (i.e. the value is the same as\n                      // the default value), and a deprecated preference is set with a\n                      // non-default value, migrate the deprecated preference value to the\n                      // new preference value.\n                      // Never remove this, because we have no means of modifying managed\n                      // preferences.\n                      // Migration code for https://github.com/mozilla/pdf.js/pull/7635.\n\n                      if (items.enableHandToolOnLoad && !items.cursorToolOnLoad) {\n                        items.cursorToolOnLoad = 1;\n                      }\n\n                      delete items.enableHandToolOnLoad; // Migration code for https://github.com/mozilla/pdf.js/pull/9479.\n\n                      if (items.textLayerMode !== 1) {\n                        if (items.disableTextLayer) {\n                          items.textLayerMode = 0;\n                        } else if (items.enhanceTextSelection) {\n                          items.textLayerMode = 2;\n                        }\n                      }\n\n                      delete items.disableTextLayer;\n                      delete items.enhanceTextSelection; // Migration code for https://github.com/mozilla/pdf.js/pull/10502.\n\n                      if (!items.showPreviousViewOnLoad && !items.viewOnLoad) {\n                        items.viewOnLoad = 1;\n                      }\n\n                      delete items.showPreviousViewOnLoad;\n                      delete items.disablePageMode;\n                      getPreferences(items);\n                    });\n                  } else {\n                    // Managed storage not supported, e.g. in old Chromium versions.\n                    getPreferences(_this2.defaults);\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function _readFromStorage(_x2) {\n        return _readFromStorage2.apply(this, arguments);\n      }\n\n      return _readFromStorage;\n    }()\n  }]);\n\n  return ChromePreferences;\n}(_preferences.BasePreferences);\n\nvar ChromeExternalServices = Object.create(_app.DefaultExternalServices);\n\nChromeExternalServices.initPassiveLoading = function (callbacks) {\n  var overlayManager = _app.PDFViewerApplication.overlayManager; // defaultUrl is set in viewer.js\n\n  ChromeCom.resolvePDFFile(_app_options.AppOptions.get('defaultUrl'), overlayManager, function (url, length, originalUrl) {\n    callbacks.onOpenWithURL(url, length, originalUrl);\n  });\n};\n\nChromeExternalServices.createDownloadManager = function (options) {\n  return new _download_manager.DownloadManager(options);\n};\n\nChromeExternalServices.createPreferences = function () {\n  return new ChromePreferences();\n};\n\nChromeExternalServices.createL10n = function (options) {\n  return new _genericl10n.GenericL10n(navigator.language);\n};\n\n_app.PDFViewerApplication.externalServices = ChromeExternalServices;",null]}